
		TOPPERS/ATK2-SC1
		ターゲット依存部 ポーティングガイド

このドキュメントは，TOPPERS/ATK2-SC1を，未サポートのターゲットシステム
にポーティングするために必要となるターゲット依存部の実装方法を説明する
ものである．

----------------------------------------------------------------------
TOPPERS ATK2
    Toyohashi Open Platform for Embedded Real-Time Systems
    Automotive Kernel Version 2

Copyright (C) 2011-2015 by Center for Embedded Computing Systems
            Graduate School of Information Science, Nagoya Univ., JAPAN
Copyright (C) 2011-2015 by FUJI SOFT INCORPORATED, JAPAN
Copyright (C) 2011-2013 by Spansion LLC, USA
Copyright (C) 2011-2015 by NEC Communication Systems, Ltd., JAPAN
Copyright (C) 2011-2015 by Panasonic Advanced Technology Development Co., Ltd., JAPAN
Copyright (C) 2011-2014 by Renesas Electronics Corporation, JAPAN
Copyright (C) 2011-2015 by Sunny Giken Inc., JAPAN
Copyright (C) 2011-2015 by TOSHIBA CORPORATION, JAPAN
Copyright (C) 2011-2015 by Witz Corporation
Copyright (C) 2014-2015 by AISIN COMCRUISE Co., Ltd., JAPAN
Copyright (C) 2014-2015 by eSOL Co.,Ltd., JAPAN
Copyright (C) 2014-2015 by SCSK Corporation, JAPAN

上記著作権者は，以下の (1)〜(3)の条件を満たす場合に限り，本ドキュメ
ント（本ドキュメントを改変したものを含む．以下同じ）を使用・複製・改
変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
(1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
    および下記の無保証規定が，そのままの形でドキュメント中に含まれて
    いること．
(2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
    を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
    ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
    りではない．
(3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
    からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
    本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
    く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

本ドキュメントは，AUTOSAR（AUTomotive Open System ARchitecture）仕様
に基づいている．上記の許諾は，AUTOSARの知的財産権を許諾するものではな
い．AUTOSARは，AUTOSAR仕様に基づいたソフトウェアを商用目的で利用する
者に対して，AUTOSARパートナーになることを求めている．

本ドキュメントは，無保証で提供されているものである．上記著作権者およ
びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
により直接的または間接的に生じたいかなる損害に関しても，その責任を負
わない．

$Id: porting.txt 1801 2015-03-27 06:34:43Z t_ishikawa $
----------------------------------------------------------------------

○目次

１．共通事項
	1.1 ターゲット依存部の構成
	1.2 多重インクルードの防止
	1.3 アセンブリ言語とのヘッダファイルの共用 
	1.4 インクルード記述の方法
	1.5 クリティカルセクションの出入処理の実現に関する制約
２．システム構築環境のターゲット依存部
	2.1 ターゲット略称とターゲット依存部のディレクトリ
	2.2 Makefileのターゲット依存部
	2.3 開発環境名とコマンド名の設定
	2.4 コンパイルオプションとオブジェクトファイルの設定
	2.5 オフセットファイルの生成方法
		2.5.1 ジェネレータを用いる方法
	2.6 リンク方法の設定
	2.7 依存関係の定義
	2.8 その他の設定
３．AUTOSAR共通定義のターゲット依存部
	3.1 整数型の最大値・最小値・ビット数
	3.2 整数型
	3.3 論理型，論理型の値
	3.4 その他の型
	3.5 コンパイラの拡張機能のためのマクロ定義
	3.6 標準的な定義の上書き
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	4.1 全割込み禁止状態の管理
	4.2 プロセッサのエンディアン
	4.3 I/O空間アクセス関数
５．カーネルAPIのターゲット依存部
	5.1 メモリ領域確保のための型定義
	5.2 メモリ領域確保のためのマクロ
	5.3 オブジェクト型の上書き
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
		6.1.1 カーネル実装のターゲット依存部の構成要素
		6.1.2 ターゲット依存部の関数の命名規則
	6.2 トレースログ機能への対応
	6.3 システム状態の管理
		6.3.1 全割込み禁止状態の管理
		6.3.2 コンテキストの管理
		6.3.3 OS割込み禁止状態の管理
	6.4 割込みに関連するシステム状態の管理
		6.4.1 割込み優先度マスクの管理
		6.4.2 割込みハンドラの先頭処理と末尾処理
	6.5 タスクディスパッチャ
		6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック
		6.5.2 ディスパッチャ本体
		6.5.3 タスクコンテキストからのディスパッチ
		6.5.4 ディスパッチャの動作開始
		6.5.5 現在のコンテキストを捨ててディスパッチ
		6.5.6 タスクの起動処理
	6.6 割込みハンドラ
		6.6.1 割込みハンドラの出入口処理
		6.6.2 割込み要求ラインの属性の設定
		6.6.3 割込み管理機能の初期化処理の変更
		6.6.4 デフォルトのC2ISR
		6.6.5 カーネル管理外の割込み
		6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更
	6.7 スタックモニタリング
	6.8 CPU例外ハンドラ
	6.9 エラーフック，シャットダウンフック呼び出し
	6.10 カーネルの起動・終了とスタック領域など
	6.11 カーネル内部のチューニング
		6.11.1 ビットマップサーチ
	6.12 カーネル実装に関するその他の定義
		6.12.1 エラーチェック方法の指定
		6.12.2 非タスクコンテキスト用のスタック領域
		6.12.3 空ラベルの定義
		6.12.4 各スタックのデフォルト値
		6.12.5 スタックマジックナンバー領域操作マクロの定義
	6.13 トレースログ機能に関する設定
		6.13.1 取得できるトレースログの種類とマクロ
		6.13.2 トレースログ記録のサンプルコード
	6.14 ハードウェアカウンタ
		6.14.1 ハードウェアカウンタのファイル構成
		6.14.2 ハードウェアカウンタの情報提供
７．ジェネレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2のテンプレートファイルのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数
		7.2.2 ターゲット非依存部で定義される変数
	7.3 パス3のテンプレートファイルのターゲット依存部
		7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数
	7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムモジュール等のターゲット依存部
	8.1 システムモジュールのターゲット依存部
	8.2 システムログ機能のターゲット依存定義
	8.3 シリアルインタフェースドライバのターゲット依存部
		8.3.1 変数，データ型，管理関数
		8.3.2 デバイスサービスルーチン
		8.3.3 コールバックルーチン
	8.4 カーネル起動メッセージの出力のターゲット依存定義
	8.5 サンプルプログラムとテストプログラムのターゲット依存定義
	8.6 実行時間分布集計モジュールのターゲット依存定義
	8.7 タイマドライバ
		8.7.1 タイマドライバのファイル構成
		8.7.2 ソフトウェアカウンタの定義
		8.7.3 時間型の定義
		8.7.4 タイマの初期化・終了処理・割込み処理
		8.7.5 現在の時刻の取得
９．その他
	9.1 ドキュメント
１０．リファレンス
	10.1 ターゲット依存部のファイル一覧


１．共通事項

1.1 ターゲット依存部の構成

ターゲット依存部は，targetディレクトリの下に，ターゲットハードウェアと
開発環境の組み合わせ毎に用意する．ただし，ターゲット依存部の再利用性を
考慮し，プロセッサ，チップ，開発環境のみに依存する部分を，プロセッサ依
存部，チップ依存部，開発環境依存部という形で切り分けてもよい．切り分け
方は，ターゲット依存部の実装に任されている．プロセッサ依存部，チップ依
存部，開発環境依存部は，archディレクトリの下に置く．

ATK2-SC1のターゲット依存部は，システム構築環境（Makefile等）のターゲッ
ト依存部，AUTOSAR仕様で規定されるPlatform_Types.hとCompiler.h，カーネ
ルAPI（Os.h）のターゲット依存部，カーネル実装のターゲット依存部（コン
フィギュレータ設定ファイルのターゲット依存部を含む），システムモジュー
ルのターゲット依存部，ターゲット依存部に関するドキュメント等で構成され
る．

1.2 多重インクルードの防止

すべてのヘッダファイルは，多重にインクルードされるのを防止するための条
件コンパイル記述を入れることとする．例えば，target_config.hであれば，
ファイルの先頭に

#ifndef TOPPERS_TARGET_CONFIG_H
#define TOPPERS_TARGET_CONFIG_H

を，ファイルの末尾に

#endif /* TOPPERS_TARGET_CONFIG_H */

を記述する．

1.3 アセンブリ言語とのヘッダファイルの共用 

ATK2-SC1のヘッダファイルの多くは，アセンブリ言語のソースファイルからも
インクルードできるようにするために，次のルールに従って記述するものとす
る．

・TOPPERS_MACRO_ONLYがマクロ定義されている場合には，アセンブリ言語では
解釈できない記述（マクロ定義以外の記述）を除くように記述する．

・符号無し整数型の定数値は，UINT_Cの整数定数を作るためのマ
  クロを用いて記述する．ただし，アセンブリ言語のソースファイルからもイ
  ンクルードできるファイル中であっても，C言語のみで用いる定数をこれら
  のマクロを使って記述する必要はない．

また，カーネル実装においては，次のルールに従うものとする．

・アセンブリ言語からも用いる定数の定義中に型キャストを用いる場合には，
  CASTマクロを用いて記述する．

アセンブリ言語からヘッダファイルをインクルードする際には，必要に応じ
て，TOPPERS_MACRO_ONLY，UINC_C，CASTをマクロ定義してから，インクルー
ドしなければならない．

1.4 インクルード記述の方法

開発環境で用意されている標準ヘッダファイルは，「#include <...>」により
インクルードする．

その他のヘッダファイルは，「#include "..."」によりインクルードする．ヘ
ッダファイルが，カレントディレクトリやインクルードするファイルと同じデ
ィレクトリ以外のディレクトリに置かれている場合には，次のようにパス指定
を行う．

・ターゲット依存部（target/<ターゲット名>）のディレクトリに置かれてい
る場合は，パス指定を行わず，ファイル名のみを記述する．
		例）#include "target_config.h"

・archディレクトリ下のディレクトリに置かれている場合には，archディレク
トリからの相対パスで記述する．
		例）#include "nios2_gcc/prc_config.h"

・その他の場合には，ソースプログラムのルートディレクトリ（configureが
  置かれているディレクトリ）からの相対パスで記述する．
		例）#include "sysmod/syslog.h"

・カーネルを構成するファイルから，kernelディレクトリ下のヘッダファイル
  をインクルードする場合は，パス指定を行わず，ファイル名のみを記述す
  る．
		例）#include "kernel_impl.h"

1.5 クリティカルセクションの出入処理の実現に関する制約

カーネル内で用いるクリティカルセクションの出入処理を実現する場合には，
次の2つの条件を満たすように実装しなければならない．

(1-5-1) 出入処理から抜けた時点では，割込みの禁止／許可が完了していなけ
ればならない．例えば，割込み禁止／許可命令を実行してから実際に割込みが
禁止／許可されるまで何命令か遅延するプロセッサの場合には，出入処理の中
にNOP命令を入れるなどの方法で，出入処理を抜けた時点では，割込みが禁止
／許可された状態になっていることを保証しなければならない．

(1-5-2) メモリ上のデータ構造が書き変わる可能性があることを，何らかの方
法でコンパイラに知らせなければならない．GNU開発環境では，次のいずれか
の方法でこの制約を満たすことができる．

(a) クリティカルセクションの出入処理の全体または出入処理の本質的な部分
    （具体的には，割込み禁止／許可する処理）を（インラインでない）通常
    の関数により実現する．

(b) クリティカルセクションの出入処理の本質的な部分をインラインアセンブ
    ラによって実現している場合には，そのインラインアセンブラのclobber
    変数リストに"memory"を追加する．

(c) クリティカルセクションの出入処理の本質的な部分が，マクロやインライ
	ン関数呼出しで実現している場合には，クリティカルセクションに入る処
	理の最後と出る処理の先頭に，Asm("" ::: "memory")という記述を入れ
	る．

このような制約を設ける理由：
カーネル内のデータ構造は，並行実行される他の処理単位（割込みハンドラや
タスク）からもアクセスされる可能性があるため，volatile宣言が必要と考え
られる．実際，クリティカルセクション内でカーネル変数を読むコードが，コ
ンパイラの最適化によりクリティカルセクション外に移動され，それが原因と
なった問題事例も報告されている．

カーネル内のすべてのデータ構造にvolatile宣言をつける方法は，安全ではあ
るが，最適化が抑止されるために，カーネルのサイズや性能には悪影響を与え
る．そこでATK2では，次の方法でvolatile宣言の必要性をなくすこと
とする．

ATK2においては，並行実行される他の処理単位から書き換えられる可
能性のあるデータ構造は，すべて，OS割込み禁止状態または全割込みロック状
態によるクリティカルセクション内でアクセスしている．クリティカルセクシ
ョン内でのデータ構造のアクセスが，コンパイラの最適化によりクリティカル
セクション外に移動されないようにするには，コンパイラに対して，クリティ
カルセクションの出入処理により，メモリ上のデータ構造が書き変わる可能性
があることを知らせればよい．

具体的には，クリティカルセクションの出入処理を関数によって実現すれば，
このような最適化を抑止することができる（(a)の制約）．しかし，実行効率
の考慮でATK2の多くのターゲット依存部において，クリティカルセク
ションの出入処理はマクロやインライン関数により実装されており，上のよう
な最適化を抑止できないため，(b)，(c)の制約を設ける．

２．システム構築環境のターゲット依存部

この章の説明は，GNU開発環境（GCC，GAS，BINUTILS，GNU Make）を用いるこ
とを想定して記述してある．それ以外の開発環境を用いる場合には，開発環境
にあわせて修正する必要がある．

2.1 ターゲット略称とターゲット依存部のディレクトリ

新しいターゲット依存部を作成する時は，まず，ターゲット略称を定める．タ
ーゲット略称は，システム略称と開発環境略称を"_"で連結したものとする．
システム略称に用いる文字は英小文字と数字と"_"に，開発環境略称に用いる
文字は英小文字と数字に限定する．GNU開発環境の開発環境略称は，"gcc"とす
る．例えば，システム略称が"nios2_dev"で，GNU開発環境を用いる場合には，
ターゲット略称は"nios2_dev_gcc"となる．

ターゲット依存部のファイルを置くために，targetディレクトリの下に，ター
ゲット略称を名称とするディレクトリを作成する．これをターゲット依存部デ
ィレクトリと呼ぶ．

ターゲット依存部からプロセッサ依存部やチップ依存部を切り分ける場合に
は，依存部略称を定める．依存部略称は，プロセッサやチップの略称と開発環
境略称を"_"で連結したものとする．プロセッサやチップの略称に用いる文字
は，英小文字と数字と"_"に限定する．例えば，プロセッサ略称が"nios2"で，
GNU開発環境を用いる場合には，依存部略称は"nios2_gcc"となる．

また，ターゲット依存部から開発環境依存部を切り分ける場合には，開発環境
略称を依存部略称とする．例えば，GNU開発環境依存部の依存部略称は，"gcc"
となる．

これらの依存部のファイルを置くために，archディレクトリの下に，依存部略
称を名称とするディレクトリを作成する．

なお，GNU開発環境以外の開発環境を用いる場合には，コンフィギュレーショ
ンスクリプト（configure），サンプルのMakefile（sample/Makefile），一部
のユーティリティプログラム（utils/makedep）を，その開発環境用に用意す
る必要がある場合がある．その場合には，これらのファイルを，ターゲット依
存部ディレクトリか開発環境依存部ディレクトリに置くものとする．また，開
発環境用のプロジェクトファイルが必要な場合には，ターゲット依存部ディレ
クトリに置くものとする．

2.2 Makefileのターゲット依存部

Makefileのターゲット依存部は，ターゲット依存部ディレクトリに置いた
Makefile.targetまたはそこからインクルードされるファイル（プロセッサ・
チップ・開発環境依存部で用意されるファイルなど）に含める．

2.3 開発環境名とコマンド名の設定

開発環境名とコマンド名を設定するために，Makefileのターゲット依存部で次
の変数を定義する．

(2-3-1) TOOL					開発環境名

開発環境名に定義する．GNU開発環境を用いる場合には，gccに定義する．

(2-3-2) GCC_TARGET				GNU開発環境のターゲット名

GNU開発環境を用いる場合に，GNU開発環境をconfigureする場合に指定するタ
ーゲット名に定義する．ここで指定したターゲット名は，開発環境のコマンド
名の先頭に付与される文字列となる．例えば，GCC_TARGETをnios2-elfに定義
した場合には，コンパイラとしてnios2-elf-gccが使われる．この変数が定義
されない場合には，単なるgccが使われる．

(2-3-3) CC						Cコンパイラドライバの名称
(2-3-4) CXX						C++コンパイラドライバの名称
(2-3-5) AS						アセンブラの名称
(2-3-6) LD						リンカの名称
(2-3-7) AR						アーカイバの名称
(2-3-8) NM						nmプログラムの名称
(2-3-9) RANLIB					ranlibプログラムの名称
(2-3-10) OBJCOPY				objcopyプログラムの名称
(2-3-11) OBJDUMP				objdumpプログラムの名称

GNU開発環境以外の開発環境を用いる場合に，それぞれのコマンドの名称に定
義する．対応するコマンドがない場合や，コマンドパラメータが異なる場合に
は，Makefile中でそのコマンドを呼び出している部分を変更する必要がある．

GNU開発環境では，これらはGCC_TARGETを用いて定義されるので，定義する必
要はない．

2.4 コンパイルオプションとオブジェクトファイルの設定

Makefileのターゲット依存部で以下で説明する変数を定義する時には，":="を
用いて，それまでの定義に追加する形で行う．例えば，コンパイラに対するそ
の他のオプションとして「-Wall -g -O2」を追加したい場合には，「COPTS :=
$(COPTS) -Wall -g -O2」という記述をMakefileのターゲット依存部に含める．

(2-4-1) COPTS				コンパイラに対するその他のオプション
(2-4-2) CDEFS				マクロ定義オプション（-Dオプション）
(2-4-3) INCLUDES			ヘッダファイルの置かれたディレクトリ指定オ
							プション（-Iオプション）
(2-4-4) LDFLAGS				リンカに対するその他のオプション
(2-4-5) LIBS				ライブラリリンク指定のためのオプション

ターゲットに依存して，すべてのソースファイルに共通するコンパイルオプシ
ョンの追加が必要な場合には，オプションの種類毎に上に示した変数に定義す
る．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，
以下の記述を含める必要がある．

----------------------------------------
INCLUDES := $(INCLUDES) -I$(TARGETDIR)
----------------------------------------

ここでTARGETDIRは，ターゲット依存部ディレクトリに定義されている．また
SRCDIRは，Makefileにおいて，ソースプログラムのルートディレクトリ
（configureが置かれているディレクトリ）に定義されている．

コンパイラの問題等で，警告メッセージが出ることを防げない状況以外では，
COPTSに-Werrorを追加することを推奨する．

----------------------------------------
COPTS := $(COPTS) -Werror
----------------------------------------

カーネルのコンパイル時に，dereferencing type-punned pointer will break
strict-aliasing rulesという警告が出る場合には，以下を追加するとよい．
この警告メッセージに関する詳細は，「TOPPERS/ASPカーネル 設計メモ」の
「型キャストに伴う警告メッセージ」の節を参照すること．

----------------------------------------
KERNEL_CFLAGS := $(KERNEL_CFLAGS) -fno-strict-aliasing
----------------------------------------

また，アセンブリ言語レベルの識別名が，C言語レベルの識別名の先頭に"_"が
付いたものになる場合には，CDEFSに-DTOPPERS_LABEL_ASMを追加する．

(2-4-6) SYSMOD_DIR		システムモジュールのソースが置かれたディレクト
                        リ
(2-4-7) SYSMOD_ASMOBJS	アセンブリ言語で記述されたシステムモジュールの
						オブジェクト
(2-4-8) SYSMOD_COBJS	C言語で記述されたシステムモジュールのオブジェ
                        クト
(2-4-9) SYSMOD_CFLAGS	システムモジュールに対するコンパイルオプション
(2-4-10) SYSMOD_LIBS	システムモジュールに対するシステムモジュール指
                        定

ターゲットに依存して，システムモジュール（デバイスドライバなど）のソー
スが置かれたディレクトリ，システムモジュールを構成するオブジェクトファ
イルのリスト，それらをコンパイルする際に適用するコンパイルオプション，
その構成に必要なシステムモジュールリンク指定を追加する場合には，上に示
した変数に定義する．

(2-4-11) KERNEL_DIR		カーネルのソースが置かれたディレクトリ
(2-4-12) KERNEL_ASMOBJS	アセンブリ言語で記述されたカーネルのオブジェク
                        ト
(2-4-13) KERNEL_COBJS	C言語で記述されたカーネルのオブジェクト
(2-4-14) KERNEL_CFLAGS	カーネルに対するコンパイルオプション

ターゲットに依存して，カーネルのソースが置かれたディレクトリ，カーネル
を構成するオブジェクトファイルのリスト，それらをコンパイルする際に適用
するコンパイルオプションを追加する場合には，上に示した変数に定義する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，
以下の記述を含める必要がある．

----------------------------------------
KERNEL_DIR := $(KERNEL_DIR) $(TARGETDIR)
KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) target_support.o
KERNEL_COBJS := $(KERNEL_COBJS) target_config.o target_hw_counter.o
----------------------------------------

(2-4-15) CFG_TABS			ジェネレータに対するオプション

ターゲットに依存して，ジェネレータに対するオプションを追加する場合には，
上に示した変数に定義する．具体的には，ジェネレータの値取得シンボルテー
ブルのターゲット依存部（target_def.csvまたは，同等の役割を持つファイル）
がある場合には，それを指定するオプションを追加する必要がある．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，
以下の記述を含める必要がある．

----------------------------------------
CFG_TABS := $(CFG_TABS) --cfg1-def-table $(TARGETDIR)/target_def.csv
----------------------------------------

(2-4-16) CFG1_OUT_LDFLAGS	cfg1_out.cに対するリンクオプション

ターゲットに依存して，cfg1_out.cをリンクする際に適用するオプションを追
加する場合には，上に示した変数に定義する．

(2-4-17) CFG_OBJS			システムコンフィギュレーションのためのオブ
							ジェクト

ターゲットに依存して，システムコンフィギュレーションのためのオブジェク
トファイルを（Os_Lcfg.o以外に）追加する場合には，上に示した変数に定義
する．この場合，追加したオブジェクトファイルの作成ルール（コンパイル／
アセンブルルールと依存関係作成ルール）を，Makefileのターゲット依存部に
記述する必要がある．

(2-4-18) CFG2_OUT

ターゲットに依存して，ジェネレータのパス2でOs_Lcfg.cとOs_Lcfg.hと
Os_Cfg.h以外のファイルを生成する場合には，上に示した変数に定義する．

(2-4-19) OMIT_WARNING_ALL
(2-4-20) OMIT_OPTIMIZATION

サンプルのMakefileでは，コンパイラに対するオプションに「-Wall -g -O2」
を追加する．-Wallを追加したくない場合には，Makefileのターゲット依存部
でOMIT_WARNING_ALLを"true"に定義する．-O2を追加したくない場合には，
Makefileのターゲット依存部でOMIT_OPTIMIZATIONを"true"に定義する．

2.5 オフセットファイルの生成方法

アセンブリ言語で記述されるプログラムから，C言語の構造体にアクセスする
場合には，構造体の各フィールドのオフセット値を参照することが必要であ
る．ATK2-SC1では，必要なオフセット値を求めてファイル（標準では
offset.h）に生成するための仕組みを用意している．

この仕組みを用いることで，例えば，TCB中のタスクコンテキストブロック
（tskctxb）に含まれるpcフィールドのオフセット値をTCB_pcにマクロ定義す
ることができる．

offset.hを生成するための仕組みとして，ジェネレータを用いる方法を用意し
ている．

これらの仕組みでオフセットファイルを生成できない時には，offset.hをター
ゲット依存部で用意し，Makefileのターゲット依存部でOMIT_MAKEOFFSETを
"true"に定義する．

2.5.1 ジェネレータを用いる方法

ジェネレータのパス1で生成するcfg1_out.cをコンパイルして生成したオブジ
ェクトファイルから，ジェネレータによってoffset.hを生成する方法である．
この方法を用いるためには，ターゲット依存部でオフセットファイル生成用テ
ンプレートファイルを用意し，target_cfg1_out.h（または，そこからインク
ルードされるファイル）とtarget_def.csv（または，同等の役割を持つファイ
ル）に記述を追加する必要がある．なお，これらのファイルを新たに用意した
際や修正した際には，offset.hに妥当な定義が生成されていることを確認すべ
きである．

オフセットファイル生成用テンプレートファイルは，ターゲット依存部で，
target_offset.tf（または，プロセッサ依存部やチップ依存部で用意するそれ
に代わるファイル）に用意する．また，Makefileのターゲット依存部で，次の
例のように，OFFSET_TFにオフセットファイル生成用テンプレートファイルの
ファイル名を定義する．

----------------------------------------
# オフセットファイル生成のための定義
OFFSET_TF = $(TARGETDIR)/target_offset.tf
----------------------------------------

オフセットファイル生成用テンプレートファイルには，以下の内容を記述す
る．

(1) 標準テンプレートファイルのインクルード

オフセットファイル生成用の標準テンプレートファイル（kernel/
genoffset.tf）をインクルードする．標準テンプレートファイルには，以下で
用いるDEFINE関数やDEFINE_BIT関数の定義などが含まれている．

----------------------------------------
$ 標準テンプレートファイルのインクルード
$INCLUDE "kernel/genoffset.tf"$
----------------------------------------

(2) オフセット値のマクロ定義の生成

DEFINE関数を用いて，オフセット値のマクロ定義を生成する．例えば，TCB中
のタスクコンテキストブロック（tskctxb）に含まれるpcフィールドのオフセ
ット値を，TCB_pcにマクロ定義する場合には，次のように記述する．

----------------------------------------
$ オフセット値のマクロ定義の生成
$DEFINE("TCB_pc", offsetof_TCB_pc)$
----------------------------------------

ここで，DEFINE関数の第1パラメータはマクロ定義するシンボル，第2パラメー
タは，オフセット値を保持するジェネレータの変数である．

また，ジェネレータが，オフセット値を保持する変数（上の例では
offsetof_TCB_pc）に値を設定するために，target_def.csv（または，同等の
役割を持つファイル）に次の例のような行を追加する．

----------------------------------------
offsetof_TCB_pc,"offsetof(TCB,tskctxb.pc)"
----------------------------------------

ただし，各オブジェクトの初期化ブロックのターゲット非依存のフィールドの
オフセット値を取得するための記述は，kernel/kernel_def.csvに含まれてい
る．kernel/kernel_def.csvに含まれている記述は，target_def.csv（または，
同等の役割を持つファイル）に追加する必要はない．

2.6 リンク方法の設定

(2-6-1) LDSCRIPT				リンカスクリプトのファイル名

開発環境に標準のリンカスクリプトが使用できない場合には，ターゲット依存
部でリンカスクリプトを用意し，そのファイル名をこの変数に定義する．

(2-6-2) TEXT_START_ADDRESS		テキストセクションの先頭番地
(2-6-3) DATA_START_ADDRESS		データセクションの先頭番地

各セクションの先頭番地の指定が必要な場合には，これらの変数に先頭番地を
定義する．

(2-6-4) START_OBJS				先頭にリンクすべきモジュール名
(2-6-5) END_OBJS				最後にリンクすべきモジュール名

ターゲットによっては，ロードモジュールの先頭と最後にリンクすべきモジュ
ールを，ターゲット依存部で用意する必要がある．多くの場合，スタートアッ
プモジュールをロードモジュールの先頭にリンクする必要がある．

ロードモジュールの先頭にリンクすべきプログラムがある場合には，Makefile
のターゲット依存部において，そのオブジェクトファイル名をSTART_OBJSに定
義し，それに対するコンパイルルールと依存関係作成ルールを定義する．ロー
ドモジュールの最後にリンクすべきモジュールがある場合には，そのオブジェ
クトファイル名をEND_OBJSに定義し，それに対するコンパイルルールと依存関
係作成ルールを定義する．また，標準のスタートアップモジュール（crt0.o）
をリンクしないように，LDFLAGSに-nostdlibを追加する必要がある．さら
に，-nostdlibをつけることで標準ライブラリがリンクされなくなるため，
LIBSに-lgccを追加しなければならない．

例えば，スタートアップモジュールのソースファイルがstart.Sの場合には，
Makefileのターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
START_OBJS = start.o

# スタートアップモジュールのコンパイルルール
$(START_OBJS): %.o: %.S
	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<

# スタートアップモジュールの依存関係作成ルール
$(START_OBJS:.o=.d): %.d: %.S
	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

また，GNU開発環境で，コンパイラに標準のcrtbegin.oとcrtend.oを用いる場合
には，Makefile のターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# オブジェクトファイル名
START_OBJS = $(shell $(CC) -print-file-name=crtbegin.o)
END_OBJS = $(shell $(CC) -print-file-name=crtend.o)

# 依存関係作成ルール
$(START_OBJS:.o=.d): %.d:
$(END_OBJS:.o=.d): %.d:

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

この場合，これらのファイルをコンパイルすることはないため，コンパイルル
ールは不要である．また，依存関係作成ルールはダミーでよい（依存関係作成
ルールがないとエラーになる）．

(2-6-6) HIDDEN_OBJS				指定しなくてもリンクされるモジュール名

ロードモジュールにリンクすべきモジュールを，リンカに対するパラメータで
はなく，リンカスクリプト中に（例えば，GNU開発環境のリンカスクリプトの
STARTUPを使って）記述する場合には，そのオブジェクトファイル名を，
（START_OBJSまたはEND_OBJSではなく）HIDDEN_OBJSに定義し，それに対する
コンパイルルールと依存関係作成ルールを定義する．HIDDEN_OBJSに定義した
モジュールは，リンカに対するパラメータからは除外される．LIBSとLDFLAGS
については，START_OBJSまたはEND_OBJSを用いる場合と同様である．

例えば，スタートアップモジュールのソースファイルがstart.Sで，start.oを
リンクすることをリンカスクリプト中に記述する場合には，Makefileのターゲ
ット依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
HIDDEN_OBJS = start.o

# スタートアップモジュールのコンパイルルール
$(HIDDEN_OBJS): %.o: %.S
	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<

# スタートアップモジュールの依存関係作成ルール
$(HIDDEN_OBJS:.o=.d): %.d: %.S
	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

2.7 依存関係の定義

ジェネレータの各パスに対して，ターゲット依存のファイルへの依存関係を定
義する．具体的には，パス1，パス2，パス3が依存するファイルを，それぞれ
cfg1_out.c，Os_Lcfg.timestamp，$(OBJFILE)に対する依存関係の形で記述する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，
以下の記述を含める必要がある．

----------------------------------------
cfg1_out.c: $(TARGETDIR)/target_def.csv
Os_Lcfg.timestamp: $(TARGETDIR)/target.tf
$(OBJFILE): $(TARGETDIR)/target_check.tf
----------------------------------------

2.8 その他の設定

(2-8-1) CLEAN_FILES				cleanにより削除するファイル名

cleanにより削除するファイルをターゲット依存部で追加したい場合には，フ
ァイル名をこの変数に追加定義する．

(2-8-2) REALCLEAN_FILES			realcleanにより削除するファイル名

realcleanにより削除するファイルをターゲット依存部で追加したい場合には，
ファイル名をこの変数に追加定義する．また，「realcleanにより削除するフ
ァイル」に「cleanにより削除するファイル」が含まれる．


３．AUTOSAR共通定義のターゲット依存部

AUTOSARで規定されているPlatform_Types.hとCompiler.hのうち，ATK2-SC1で
必要なものについて説明する．また，AUTOSARでは規定されていないが，
ATK2-SC1で必要となるものについて説明する．

3.1 整数型の最大値・最小値・ビット数

(3-1-1) INT_MAX				intに格納できる最大値（C90準拠）
(3-1-2) UINT_MAX			unsigned intに格納できる最大値（C90準拠）
(3-1-3) LONG_MAX			longに格納できる最大値（C90準拠）
(3-1-4) CHAR_BIT			char型のビット数（C90準拠）
(3-1-5) CHAR_MAX			char型に格納できる最大値（C90準拠）
(3-1-6) CHAR_MIN			char型に格納できる最小値（C90準拠）
(3-1-7) SCHAR_MAX			signed short型に格納できる最大値（C90準拠）
(3-1-8) SHRT_MAX			short型に格納できる最大値（C90準拠）

整数型の最大値・最小値・ビット数を，これらのシンボルにマクロに定義する．

これらのマクロは，C90に準拠したものである．開発環境にC90に準拠した
limits.hが用意されている場合には，これらのマクロを定義することに代え
て，limits.hをインクルードすればよい．

3.2 整数型

(3-2-1) sint8				符号付き8ビット整数
(3-2-2) uint8				符号無し8ビット整数
(3-2-3) sint16				符号付き16ビット整数
(3-2-4) uint16				符号無し16ビット整数
(3-2-5) sint32				符号付き32ビット整数
(3-2-6) uint32				符号無し32ビット整数
(3-2-7) sint64				符号付き64ビット整数
(3-2-8) uint64				符号無し64ビット整数
(3-2-9) sintptr				ポインタを格納できるサイズの符号付き整数
(3-2-10) uintptr			ポインタを格納できるサイズの符号無し整数

指定されたサイズの整数型を，これらのシンボルに型定義する．
また，ターゲットによって，最高実行効率を達成するため，以下の最適整数型
を指定されたサイズ関係なく，型定義する（カーネル内部使用していない）．
但し，定義した型は，指定されたサイズの最大値，最小値を表現できなければ
いけない．

(3-2-11) sint8_least		符号付き8ビット整数の最適型
(3-2-12) uint8_least		符号無し8ビット整数最適型
(3-2-13) sint16_least		符号付き16ビット整数の最適型
(3-2-14) uint16_least		符号無し16ビット整数最適型
(3-2-15) sint32_least		符号付き32ビット整数の最適型
(3-2-16) uint32_least		符号無し32ビット整数最適型

3.3 論理型，論理型の値

(3-3-1) boolean				論理型
(3-3-2) TRUE				符号付き8ビット整数
(3-3-3) FALSE				符号無し8ビット整数

これらはターゲット非依存だが，AUTOSARではPlatform_Types.hで定義すると
規定されている．それぞれ以下のように定義する．

----------------------------------------
typedef unsigned char	boolean;
#define TRUE			UINT_C(1)
#define FALSE			UINT_C(0)
----------------------------------------

3.4 その他の型

(3-4-1) char8				8ビット文字型
(3-4-8) float32				単精度浮動小数点数型
(3-4-9) float64				倍精度浮動小数点数型

3.5 コンパイラの拡張機能のためのマクロ定義

コンパイラの拡張機能を用いるためのマクロとして，必要に応じて，以下のマ
クロの定義を含める．

(3-5-1) LOCAL_INLINE

インライン関数であることを示す指定．LOCAL_INLINEは，コンパイル単位にロ
ーカルなインライン関数であることを示す．

(3-5-2) Asm（オプション，デフォルトは未定義）

インラインアセンブラを記述するための指定．Asmは，最適化により削除して
はならないことを示す．これらは，ターゲット依存部でのみ使うマクロである
ため，ターゲット依存部で使わないなら定義する必要はない．

(3-5-3) offsetof(structure, field)（オプション，デフォルトの定義あり）

構造体structureの中での，フィールドfieldのオフセットを求めるマクロ．

(3-5-4) NoReturn（オプション，デフォルトは未定義）

リターンすることのない関数であることを示す指定．このような関数を宣言す
ることによって，その関数が復帰しないということをコンパイラに知らせるこ
とができ，コンパイラは，この場合には復帰することを考えず，復帰の後処理
を省略するので，少しコンパクトなコードが生成される．これは，ターゲット
依存部で定義する必要がある．これは，ターゲット依存部のみ使うマクロであ
るため，ターゲット依存部で使わないなら定義する必要はない．

3.6 標準的な定義の上書き

Std_Types.hに含まれる標準的な定義を上書きする場合には，
以下のマクロを定義する．


(3-6-1) UINT_C(val)（オプション，デフォルトはUを付加）

符号無し整数型の定数を作るためのマクロ．

(3-6-3) NULL（オプション，デフォルトは0）

C90準拠のC言語環境では，NULLの定義はstddef.hに含まれているため，これを
インクルードしてもよい．

４．システムインタフェースレイヤ（SIL）のターゲット依存部

システムインタフェースレイヤ（SIL）のターゲット依存部の定義は，syslog
からのみ使われるため，target_sysmod.hまたはそこからインクルードされる
ファイル（プロセッサ・チップ・開発環境依存部で用意されるヘッダファイル
など）に含める．

SILのサービスコールは，任意のシステム状態で呼び出すことができる．そのた
め，SILのターゲット依存部の関数は，任意のシステム状態で呼び出せるように
実装しなければならない．

4.1 全割込み禁止状態の管理

SILのターゲット依存部では，全割込み禁止状態へ遷移する機能と，元の状態
へ戻す機能（元の状態を記憶するために変数を使う）を提供する．全割込みロ
ック状態であるかを判別する機能は提供する必要がない．

SILの機能は，カーネルを使用しない場合にも使用できる必要がある．そのた
め，全割込み禁止状態への遷移と元の状態への復帰は，カーネルを用いず，プ
ロセッサのリソースを直接操作することによって実現する．また，全割込みロ
ック状態への遷移と元の状態への復帰は，全割込み禁止状態やOS割込み禁止状
態でも行える必要がある．

(4-1-1) SIL_PRE_LOC

全割込み禁止フラグの状態を保存するための変数を定義するマクロ．型名の
後に，変数名を続けたものに定義する．変数名は，他の名前と衝突しないよう
に，"TOPPERS_"で始まる名前にする．

(4-1-2) SIL_LOC_INT()

現在の全割込み禁止フラグの状態をSIL_PRE_LOCで定義した変数に保存し，全
割込み禁止状態に遷移させるマクロ．このマクロを実現する際には，「1.6
クリティカルセクションの出入処理の実現に関する制約」の節に記述されてい
る制約に従わなければならない．

(4-1-3) SIL_UNL_INT()

SIL_LOC_INT()によって変数に保存した状態に戻すマクロ．このマクロを実現
する際には，「1.5 クリティカルセクションの出入処理の実現に関する制約」
の節に記述されている制約に従わなければならない．

4.2 プロセッサのエンディアン

(4-2-1) SIL_ENDIAN_BIG

プロセッサは，ビッグエンディアンの場合，SIL_ENDIAN_BIGのシンボルをマク
ロ定義する．SIL_ENDIAN_BIGの定義がない場合，リトルエンディアンとする．

4.3 I/O空間アクセス関数

メモリ空間とは別にI/O空間を持つプロセッサでは，I/O空間にあるデバイスレ
ジスタをアクセスするための関数として，sil_reb_iop，sil_wrb_iop，
sil_reh_iop，sil_wrh_iop，sil_reh_lep，sil_wrh_lep，sil_reh_bep，
sil_wrh_bep，sil_rew_iop，sil_wrw_iop，sil_rew_lep，sil_wrw_lep，
sil_rew_bep，sil_wrw_bepの中で必要なものを，ターゲット依存部で用意す
る．

I/O空間とメモリ空間は区別しなく，キャッシュを無効にしたい場合でも，こ
れらの関数を用いること．

５．カーネルAPIのターゲット依存部

カーネルAPI（Os.h）のターゲット依存部の定義は，target_kernel.hまた
はそこからインクルードされるファイル（プロセッサ・チップ・開発環境依存
部で用意されるヘッダファイルなど）に含める．

5.1 メモリ領域確保のための型定義

(5-1-1) TOPPERS_STK_T	スタック領域を確保するための型（オプション）

スタック領域は，標準では，sintptr型の配列として確保するが，より大きい
単位でアラインさせたいなどの理由で，それ以外の型の配列として確保する場
合には，TOPPERS_STK_Tを，配列のベースとなるデータ型にマクロ定義する．

5.2 メモリ領域確保のためのマクロ

(5-2-1) TOPPERS_ROUND_SZ（オプション）
(5-2-2) TOPPERS_COUNT_SZ（オプション）

TOPPERS_COUNT_SZ(sz, unit)は，sz/unitを切り上げた値を求めるマクロで，
サイズがszバイトのメモリ領域をサイズがunitバイトのデータ型の配列で確保
する場合の要素数を求めるために用いる．TOPPERS_ROUND_SZ(sz, unit)は，sz
/unitを切り上げたものにunitをかけた値を求めるマクロで，サイズがszのメ
モリ領域をサイズがunitのデータ型の配列で確保する場合のトータルサイズを
求めるために用いる．

それぞれ，標準のTOPPERS_ROUND_SZ，TOPPERS_COUNT_SZが適切でなく，ターゲ
ット依存部で用意する場合には，これらのシンボルを適切な値にマクロ定義す
る．

5.3 オブジェクト型の上書き

(5-3-1) OMIT_DATA_TYPE (オプション)

OMIT_DATA_TYPEマクロをターゲット依存部で定義した場合は，一部のオブジェ
クトの型をターゲット依存部で定義することができる．

(5-3-2)  TimeType              (オプション，デフォルトはuint32)
(5-3-3)  AlarmType             (オプション，デフォルトはuint32)
(5-3-4)  ResourceType          (オプション，デフォルトはuint32)
(5-3-5)  TaskType              (オプション，デフォルトはuint32)
(5-3-6)  ISRType               (オプション，デフォルトはuint32)
(5-3-7)  CounterType           (オプション，デフォルトはuint32)
(5-3-8)  ScheduleTableType     (オプション，デフォルトはuint32)
(5-3-9)  PhysicalTimeType      (オプション，デフォルトはfloat32)
(5-3-10) InterruptNumberType   (オプション，デフォルトはuint32)
(5-3-11) AttributeType         (オプション，デフォルトはuint32)
(5-3-12) PriorityType          (オプション，デフォルトはsint32)

OMIT_DATA_TYPEマクロをターゲット依存部で定義した場合は，これらのオブジ
ェクト型をターゲット依存部で定義する必要がある．

また，OMIT_DATA_TYPEマクロをターゲット依存部で定義した場合は，一部のオ
ブジェクトの無効値をターゲット依存部で定義する必要がある．

(5-3-13) INVALID_TASK         (オプション，デフォルトはUINT32_INVALID)
(5-3-14) INVALID_ISR          (オプション，デフォルトはUINT32_INVALID)

備考：カーネルでUINT32_INVALIDが定義済み「#define UINT32_INVALID 
(UINT32_MAX)」

６．カーネル実装のターゲット依存部

6.1 カーネル実装のターゲット依存部の共通事項

6.1.1 カーネル実装のターゲット依存部の構成要素

カーネル実装のターゲット依存部は，以下の要素で構成される．

(a) カーネル実装のターゲット依存の定義

カーネル実装のターゲット非依存部から参照されるターゲット依存の定義は，
target_config.hまたはそこからインクルードされるファイル（プロセッサ・
チップ・開発環境依存部で用意されるヘッダファイルなど）に含める．

ターゲットのハードウェア資源（割込み番号やデバイスレジスタの番地など）
の定義は，ライブラリやアプリケーションにも有用であるため，カーネル実装
のみに有用な定義を含むファイルとは切り分けて，独立したヘッダファイルに
含める．このヘッダファイルの標準的な名称を，システム略称.h（または，
チップ略称.h，プロセッサ略称.h）とする．

(b) カーネル実装のターゲット依存モジュール

カーネル実装のターゲット依存の変数定義や関数を含むモジュール．C言語で
記述される部分をtarget_config.c，アセンブリ言語で記述される部分を
target_support.Sに含める．プロセッサ・チップ・開発環境依存部を切り分け
ることや，ファイルが大きくなる場合に複数のファイルに分割することも可能
である．

(c) ジェネレータ設定ファイル

ジェネレータの設定ファイルのターゲット依存部を，target_def.csv，
target.tf，target_check.tfに用意する．ジェネレータ設定ファイルの記述方
法については，７章で説明する．

6.1.2 ターゲット依存部の関数の命名規則

カーネル実装のターゲット依存部を構成する関数の中で，i_で始まるものは非
タスクコンテキスト専用，x_で始まるものはいずれのコンテキストからでも呼
び出すことができる関数である．

6.2 トレースログ機能への対応

カーネルのトレースログ機能の中で，ディスパッチャのトレースログ取得は，
ターゲット依存部で実装する必要がある．ほとんどのターゲットシステムにお
いて，それらの処理はアセンブリ言語で記述されており，ターゲット非依存部
向けのトレースログマクロと同じ方法（トレースログマクロを，トレースログ
取得処理のC言語記述にマクロ定義する方法）は，用いることができない．

そこで，アセンブリ言語で記述されている処理中にトレースログ取得を埋め込
む場合には，トレースログマクロが定義されていれば，それが何に定義されて
いるかは無視して，標準的なトレースログ関数がC言語で記述されていると想定
して，それを呼び出すようにコーディングする．

具体的には，下の表の左側に示したトレースログマクロが定義されていれば，
表の右側に示したC言語記述と同等の処理を行うようにコーディングする．

	トレースログマクロ		トレースログ取得処理
	-----------------------------------------------
	LOG_DSP_ENTER			log_dsp_enter(p_runtsk)
	LOG_DSP_LEAVE			log_dsp_leave(p_runtsk)

6.3 システム状態の管理

ATK2-SC1を新たなターゲットシステムにポーティングする際に，最も重要な
作業は，カーネルが定義するシステム状態を，ハードウェア（プロセッサ）上
でどのように実現するかである．

6.3.1 全割込み禁止状態の管理

全割込み禁止状態は，NMIを除くすべての割込みをマスクした状態である．
ターゲット依存部は，全割込み禁止状態へ遷移する機能，全割込み禁止解除状
態へ遷移する機能を提供する．

(6-3-1-1) void x_lock_all_int(void)
(6-3-1-2) void x_unlock_all_int(void)

6.3.2 コンテキストの管理

処理単位が実行されるコンテキストは，タスクコンテキストと非タスクコンテ
キストに分類される．

(6.3.2.1) タスクコンテキスト

タスクの実行に必要な各種情報のことであり，CPUの各レジスタ等が該当する．

(6.3.2.2) 非タスクコンテキスト

タスクを除く，全ての処理単位のコンテキストを意味する．

ターゲット依存部では，C2ISRとCPU例外の入口処理で非タスクコンテキストに
切り換え，それらの出口処理で元のコンテキストに戻す．また，ディスパッチ
ャの内部で一時的に非タスクコンテキストに切り換える．

6.3.3 OS割込み禁止状態の管理

ターゲット依存部は，OS割込み禁止状態へ遷移する機能，OS割込み禁止解除状
態へ遷移する機能を提供する．

(6-3-3-1) void x_nested_lock_os_int(void)
(6-3-3-2) void x_suspend_lock_os_int(void)

OS割込み禁止解除状態から，OS割込み禁止状態へ遷移させる関数．これらの関
数はネストして呼び出された場合は，ネストカウントを1増やす．
x_suspend_lock_os_intはC1ISR実行中に呼ばれる場合があり，その場合は既に
OS割り込み禁止状態になっているため，何もする必要がない．
x_nested_lock_os_intはC1ISRから呼び出されることはなく，呼び出された場
合の動作は保証する必要がない．

これらの関数を実現する際には，「1.5 クリティカルセクションの出入処理の
実現に関する制約」の節に記述されている制約に従わなければならない．

(6-3-3-3) void x_nested_unlock_os_int(void)
(6-3-3-4) void x_resume_unlock_os_int(void)

OS割込み禁止状態から，OS割込み禁止解除状態へ遷移させる関数．これらの関
数は，OS割込み禁止解除状態で呼び出されることはなく，呼び出された場合の
動作は保証する必要がない．x_nested_lock_os_int, x_suspend_lock_os_int
がネストして呼び出されている場合は，ネストカウントを1減らし，ネストカ
ウントが0になった場合に，OS割込み禁止解除状態へ遷移させる．
x_resume_unlock_os_intはC1ISRから呼び出されることがあるが，その場合は
何もする必要がない．x_nested_unlock_os_intはC1ISRから呼び出されること
はなく，呼び出された場合の動作は保証する必要がない．

これらの関数を実現する際には，「1.6 クリティカルセクションの出入処理の
実現に関する制約」の節に記述されている制約に従わなければならない．

6.4 割込みに関連するシステム状態の管理

6.4.1 割込み優先度マスクの管理

ターゲット依存部は，割込み優先度マスクを設定する機能と，割込み優先度マ
スクを参照する機能を提供する．

(6-4-1-1) void x_set_ipm(PriorityType intpri)

割込み優先度マスクの値をintpriに設定する関数．

x_set_ipmは，ターゲット非依存部がOS割込み禁止解除状態で呼び出すことは
ないため，OS割込み禁止解除状態で呼び出された場合の動作は保証する必要が
ない．

また，これらの関数は，
-(C2ISRの最高優先度) <= intpri && intpri <= -1を満たすintpriに対しての
み呼ばれる．intpriにそうでない値が渡された場合の動作は保証する必要がな
い．

(6-4-1-2) PriorityType x_get_ipm(void)

割込み優先度マスクの値を参照して返す関数．

x_get_ipmは，ターゲット非依存
部がOS割込み禁止解除状態で呼び出すことはないため，OS割込み禁止解除状態
で呼び出された場合の動作は保証する必要がない．

6.4.2 割込みハンドラの先頭処理と末尾処理

(6-4-2-1) void i_begin_int(InterruptNumberType intno)

intnoで指定された割込み要求ラインに対するC2ISRの先頭で行うべき処理を行
う関数．ここで行うべき処理としては，割込み要求ラインがエッジトリガであ
る場合のトリガされた割込み要求のクリアが挙げられる．

intnoに対して登録されたC2ISRの直前に呼び出される．

(6-4-2-2) void i_end_int(InterruptNumberType intno)

intnoで指定された割込み要求ラインに対するC2ISRの末尾で行うべき処理を行
う関数．ここで行うべき処理としては，割込みコントローラ（IRC）に対する
割込み処理の終了通知が挙げられる．

intnoに対して登録されたC2ISRの直後で呼び出される．

ターゲットによっては，IRCに対する割込み処理の終了通知を行う前に，すべ
ての割込みを禁止しなければならない場合がある．この場合には，この関数の
中で割込みを禁止してもよいが，関数をリターンする前に，元の状態に戻す必
要がある．

6.5 タスクディスパッチャ

6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック

(6-5-1-1) TSKCTXB

ターゲット依存のタスクコンテキストを保存するために，TCB中に持つことが
必要なデータ構造の型を，TSKCTXBに定義する．標準的には，TSKCTXBには，
タスクのスタックポインタと実行再開番地を格納する．

(6-5-1-2) USE_TSKINICTXB（オプション）
(6-5-1-3) TSKINICTXB（オプション）

ターゲット依存の情報をタスク初期化ブロック（TINIB）に入れたい場合や，
TINIB中のスタック領域のサイズと先頭番地の持ち方をターゲット依存に変更
したい場合には，USE_TSKINICTXBをマクロ定義し，TINIB中に持つことが必要
なデータ構造の型を，TSKINICTXBに定義する．

USE_TSKINICTXBをマクロ定義すると，TINIB中にスタック領域のサイズと先頭
番地が含まれなくなるため，それに代わる情報をTSKINICTXB中に持つ必要があ
る．
また，ジェネレータのパス2のテンプレートファイルのターゲット非依存部で，
TSKINICTXBの初期化情報を生成するためのGENERATE_TSKINICTXBを，パス3のテ
ンプレートファイルのターゲット非依存部で，TINIBからスタック領域の先頭
番地を取り出すためのGET_STK_TSKINICTXBを定義する必要がある．

6.5.2 ディスパッチャ本体

ディスパッチャ本体（dispatcher）は，ターゲット非依存部から直接呼び出さ
れることはなく，カーネルのターゲット依存部の内部からのみ呼び出される．
dispatcherは，タスクコンテキスト・OS割込み禁止状態・割込み優先度マスク
全解除状態から呼び出される．

dispatcherの処理内容は次の通り．

----------------------------------------
void
dispatcher(void)
{
#ifdef CFG_USE_STACKMONITORING
	スタックポインタ方式によるスタックモニタリング
	マジックナンバー方式によるスタックモニタリング
#endif /* CFG_USE_STACKMONITORING */

#ifdef CFG_USE_POSTTASKHOOK
	if (PostTaskHook != 0) {
		非タスクコンテキストに切り替える
		call_posttaskhook();
		コンテキストを戻す
	}
#endif /* CFG_USE_POSTTASKHOOK */

  dispatcher_0:
#ifdef LOG_DSP_ENTER
	log_dsp_enter(p_runtsk);
#endif /* LOG_DSP_ENTER */

	if (callevel_stat & TSYS_DISALLINT) {
		callevel_stat &= ~TSYS_DISALLINT;
		全割込み禁止を解除する
	}

  dispatcher_1:
	while ((p_runtsk = p_schedtsk) == NULL) {
		割込みを許可したらOS割込み禁止解除状態になるよう準備する
		非タスクコンテキストに切り換える
		OS割込み禁止を解除し，割込み発生を待つ … (*1)
		OS割込み禁止状態に戻す … (*2)
		タスクコンテキストに戻す
	}
	自タスク（p_runtsk）のTCBからスタックポインタを復帰する
#ifdef LOG_DSP_LEAVE
	log_dsp_leave(p_runtsk);
#endif /* LOG_DSP_LEAVE */

#ifdef CFG_USE_PRETASKHOOK
	if (PreTaskHook != 0) {
		非タスクコンテキストに切り替える
		call_pretaskhook();
		タスクコンテキストに戻す
	}
#endif /* CFG_USE_PRETASKHOOK */

	自タスクのTCBから実行再開番地を復帰し，そこへ分岐する
}
----------------------------------------

割込み発生を待つ間に非タスクコンテキストに切り換えるのは，この間に実行
される割込みハンドラ内で，タスクディスパッチをしないようにするためであ
る．この時，割込みハンドラが，非タスクコンテキスト用のスタックを使うよ
うにしなければならない．通常は，非タスクコンテキストに切り換える際に非
タスクコンテキスト用のスタックに切り換え，タスクコンテキストに戻す際に
元のスタックに切り換える．

ターゲットによっては（特に，シミュレーション環境の場合），強制的に非タ
スクコンテキストに切り換えることが難しい場合がある．その場合には，この
間に実行される割込みハンドラ内でタスクディスパッチをしないような仕組み
を実装することで，非タスクコンテキストへの切換えを省略することができる．

(*1)において，割込みを許可する処理と，割込み発生を待つ処理とは，不可分
に行なう必要がある．これを不可分に行なわない場合，割込みを許可した直後
に割込みが入り，その中でタスクが実行可能状態になると，実行すべきタスク
があるにもかかわらずプロセッサが割込み待ちになってしまう．

また，(*1)において，割込み発生を待つ命令が用意されていない場合や，それ
を発行するのが不都合な場合には，割込みをすべて許可して割込みを受け付け
られる状態になった後に，割込み発生を待たずに次に進んでもよい．この場合，
whileループによって，割込み発生を待つことになる．

OS割込み禁止を解除するための情報（例えば，OS割込み禁止前の割込み優先度
マスク）を変数に保持している場合には，(*2)でOS割込み禁止状態に戻す際に，
その変数の値も元に戻っている必要がある．特に，その変数が，割込み待ちの
間に実行した割込みハンドラ内で書き換えられる場合は，元の値に戻すことが
必要である．

割込み待ちの間は，p_runtskをNULL（＝0）に設定しなければならない（上の
処理内容をそのまま実装すればこうなる）．このように設定しないと，割込み
ハンドラからGetTaskIDを呼び出した際の動作が仕様に合致しなくなる．

タスクディスパッチによるタスク切り替え前に，CFG_USE_POSTTASKHOOK定義さ
れ，ユーザがポストタスクフックを定義した場合（PostTaskHook != NULL），
ポストタスクフック呼び出しインターフェース（call_posttaskhook）を呼出
す必要がある．
その一方，タスクディスパッチによるタスク切り替え後に，
CFG_USE_PRETASKHOOK定義され，ユーザがプレタスクフックを定義した場合
（PreTaskHook != NULL），プレタスクフック呼び出しインターフェース
（call_pretaskhook）を呼出す必要がある．
そこで，アセンブリ言語で記述されているディスパッチャ処理中にプレ/ポス
トタスクフックの呼び出しを埋め込む．標準的なプレ/ポストタスクフックが
C言語で記述されていると想定して，それを呼び出すようにコーディングする．

dispatcherをアセンブリ言語で記述する場合には，トレースログ取得処理は，
「6.2 トレースログ機能への対応」の節で記述した方法でコーディングするこ
と．なお，log_dsp_enterは切換え前のタスクのスタックで，log_dsp_leave 
は切換え後のタスクのスタックで実行する．

6.5.3 タスクコンテキストからのディスパッチ

(6-5-3-1) void dispatch(void)

タスクコンテキストからのディスパッチ（dispatch）は，タスクコンテキスト
用のシステムサービス処理においてタスク切換えが必要になった場合に，ター
ゲット非依存部のシステムサービス処理関数から呼び出される．

dispatchは，タスクコンテキスト・OS割込み禁止状態・割込み優先度マスク全
解除状態で呼び出される．

dispatchの処理内容は次の通り．

----------------------------------------
void
dispatch(void)
{
	スクラッチレジスタ(*)を除くすべてのレジスタをスタックに保存する
	スタックポインタを自タスク（p_runtsk）のTCBに保存する
	dispatch_rを，実行再開番地として自タスクのTCBに保存する
	dispatcherに分岐する

  dispatch_r:
	スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
}
----------------------------------------

ここでスクラッチレジスタ(*)とは，関数呼出しにより保存されないレジスタ
のことである．必要な場合には，関数を呼び出す側で保存しなければならない
ため，caller saved registerと呼ばれる場合もある．

dispatchを呼び出したタスクが次に実行される時には，実行再開番地として登
録したdispatch_rに戻ってくる．dispatch_rには，dispatcherのみから分岐し，
その時の状態は，タスクコンテキスト・OS割込み禁止状態・割込み優先度マス
ク全解除状態である．

6.5.4 ディスパッチャの動作開始

(6-5-4-1) void start_dispatch(void)

ディスパッチャの動作開始（start_dispatch）は，カーネル起動時に，カーネ
ルの初期化処理から呼び出される．start_dispatchは，リターンすることのな
い関数である．

start_dispatchは，非タスクコンテキストで，NMIを除くすべての割込みをマ
スクした状態（全割込み禁止状態と同等の状態）で呼び出される．
start_dispatch内で，タスクコンテキストに切り換え，OS割込み禁止状態・割
込み優先度マスク全解除状態にしなければならない．

start_dispatchの処理内容は次の通り．

----------------------------------------
void
start_dispatch(void)
{
	タスクコンテキストに切り換える
	OS割込み禁止状態・割込み優先度マスク全解除状態にする
	dispatcher_0に分岐する
}
----------------------------------------

6.5.5 現在のコンテキストを捨ててディスパッチ

(6-5-5-1) void exit_and_dispatch(void)

現在のコンテキストを捨ててディスパッチ（exit_and_dispatch）は，自タス
クを終了させるシステムサービス処理関数から呼び出される．
exit_and_dispatchは，リターンすることのない関数である．

exit_and_dispatchは，タスクコンテキスト・OS割込み禁止状態・割込み優先
度マスク全解除状態で呼び出される．

exit_and_dispatchの処理内容は次の通り．

----------------------------------------
void
exit_and_dispatch(void)
{
	dispatcherに分岐する
}
----------------------------------------

6.5.6 タスクの起動処理

(6-5-6-1) void activate_context(TCB *p_tcb)

タスクの起動処理（activate_context）は，タスクを休止状態から実行できる
状態にする時に呼ばれ，p_tcbで指定されたタスク（対象タスク）のTCB中のス
タックポインタを初期化し，実行再開番地をタスク開始時処理（start_r）に
設定する．この時点では，後述する理由で，対象タスクのスタック領域を使っ
てはならない．

対象タスクが最初に実行される時には，対象タスクを自タスクとして，実行再
開番地として登録したstart_rに分岐してくる．start_rには，dispatcherのみ
から分岐し，その時の状態は，タスクコンテキスト・OS割込み禁止状態・割込
み優先度マスク全解除状態である．

start_rは，OS割込み禁止状態を解除した後，タスクの起動番地を呼び出す．
さらに，タスクの起動番地から戻ってきた場合には，exit_taskを呼び出す．

activate_contextとstart_rの処理内容は次の通り．

----------------------------------------
void
activate_context(TCB *p_tcb)
{
	指定されたタスク（p_tcb）のTCB中のスタックポインタを初期化する
	start_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	return;

  start_r:
    p_runtsk->curpri = p_runtsk->p_tinib->exepri;
	OS割込み禁止解除状態にする
	自タスク（p_runtsk）の起動番地を呼び出す
	exit_taskに分岐する … (*c)
}
----------------------------------------

(*c)でexit_taskを呼ぶ代わりに，自タスクの起動番地を呼び出す時の返り番
地をexit_taskの番地としておく方法がある．

ここで，タスクの起動処理において対象タスクのスタック領域を使ってはなら
ない理由は，次の通り．複数の基本タスクがスタック領域を共有している場合
に，タスクの起動時点では，そのタスクとスタック領域を共有しているタスク
が，スタック領域を使用している可能性があるためである．

このポーティングガイドでは，タスクの実行再開番地をTCBに保存している
(*a)．これをスタックに保存する方法も考えられるが，タスクの起動処理でス
タック領域が使えないことから，タスクの起動処理だけは例外扱いしなければ
ならない．例えば，タスクの起動処理においてはTCB中のスタックポインタを特
殊な値（例えば0）に設定しておき，ディスパッチャ本体でTCB中のスタックポ
インタがその値の場合にはstart_rに分岐させ，start_rにおいてスタックポイ
ンタを初期化する方法が考えられる．

6.6 割込みハンドラ

6.6.1 割込みハンドラの出入口処理

C2ISRの割込みの出入口処理の方法は，プロセッサによって大きく異なるが，
おおよその処理内容は次の通り．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	少なくともOS割込みを禁止した状態にする … (*f)
	スクラッチレジスタをスタックに保存する
	if (タスクコンテキストで割込み発生) {
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
	割込み優先度マスクを，受け付けた割込み要求の割込優先度に設定し，
				OS割込み禁止解除状態にする（受け付けた割込みよりも
				優先度の高い割込みを受け付けるようにする）… (*i)

#ifdef CFG_USE_STACKMONITORING
	if (タスクコンテキストで割込み発生) {
		スタックポインタチェック方式でタスクスタックのスタックモニタリ
		ングを行う
		マジックナンバーチェック方式でタスクスタックのスタックモニタリ
		ングを行う
	}
	else {
		スタック残量チェック方式でC2ISR用スタックのスタックモニタ
		リングを行う
		マジックナンバーチェック方式でC2ISR用スタックのスタックモニタ
		リングを行う
	}
#endif /* CFG_USE_STACKMONITORING */

	callevel_statを保存
	callevel_statに割込みビットを立てる
	p_runisrを保存
	p_runisrを実行するC2ISRに対応するisrcb_tableの要素に設定する

	C2ISRを呼び出す

#ifdef CFG_USE_STACKMONITORING
	マジックナンバーチェック方式でC2ISR用スタックのスタックモニタリン
	グを行う
#endif /* CFG_USE_STACKMONITORING */

	exit_isr2();			/* C2ISRの不正終了チェック */

	p_runisrを復帰
	callevel_statを復帰

  ret_int:
	if (タスクコンテキストで割込み発生) {
		（少なくとも）OS割込みを禁止した状態にする
		スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
		if (p_runtsk != p_schedtsk) {
			OS割込み禁止状態にする … (*e)
			割込み優先度マスクを，全解除状態（TIPM_ENAALL）に設定する
								 … (*h)
			スクラッチレジスタを除くすべてのレジスタをスタックに保存す
			る
			スタックポインタを自タスク（p_runtsk）のTCBに保存する
			ret_int_rを，実行再開番地として自タスクのTCBに保存する

			dispatcherに分岐する

		  ret_int_r:
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰
			する
		}
	}
	割込み処理からのリターン後に，割込み優先度マスクが
								割込み処理前の値に戻るように準備する
	割込み処理からのリターン後に，OS割込み禁止解除状態に戻るように準備
	する
	スクラッチレジスタをスタックから復帰する
	割込み処理からのリターン
}
----------------------------------------

割込みの受付けにより，スタックポインタが切り換わらず，すべての割込みが
禁止されないプロセッサでは，(*f)において，少なくともOS割込みを禁止す
る．
この理由は次の通りである．

割込みの入口処理において，スタックを非タスクコンテキスト用のスタックに
切り換える前に多重割込みが発生すると，タスクのスタック領域が使用され
る．
上記のようなプロセッサでは，スタックの切換え前に，最大で割込み優先度の
段数分の多重割込みが発生することを防ぐことはできず，各タスクのスタック
領域を確保する際に，その分を見込んで確保しなければならない．各タスクの
スタック領域をなるべく小さくするためには，スタックをなるべく使用しない
内に，多重割込みを禁止するのが望ましい．そのため，スクラッチレジスタを
スタックに保存する前に，割込みを禁止する．ただし，割込みの禁止処理に必
要な最低限のレジスタについては，割込みの禁止に先立ってスタックに保存す
る必要がある．

同様のことは，カーネル管理外の割込みにも当てはまる．すなわち，カーネル
管理外の割込みについても，スタックをなるべく使用しない内に禁止するのが
望ましい．このことから，カーネル管理外の割込みを使用する場合には，(*f)
において，すべての割込みを禁止した状態にするのが望ましいことになる．一
方で，カーネル管理外の割込みの禁止時間が長くなると，カーネル管理外の割
込みの応答性が低下するため，ユーザに注意を促す必要がある．また，カーネ
ル管理外の割込み処理においても，非タスクコンテキスト用のスタック（また
は，カーネル管理外の割込み処理用のスタック）に切り換えることが望ましい
が，これはカーネルの管轄外である．

(*i)に含まれる割込み優先度マスクを設定する処理は，プロセッサがハードウ
ェアで実現している場合も多い．

(*e)においてOS割込み禁止状態にするのは，dispatcherに分岐する際には，
OS割込み禁止状態になっている必要があるためである．

(*h)の処理が実行されるのは，割込み処理前に割込み優先度マスクが全解除状
態（TIPM_ENAALL）であった場合に限られ，ここで割込み優先度マスクを全解
除状態に設定するのは，割込み処理前の値に戻すのと等価である．ここでこの
処理を行うのは，dispatcherに分岐する際には，割込み優先度マスク全解除状
態になっている必要があるためである．

タスクの実行中に割込みが発生し，上の処理中でdispatcherに分岐した場合，
そのタスクが次に実行される時には，実行再開番地として登録したret_int_r
に戻ってくる．ret_int_rには，dispatcherのみから分岐し，その時の状態は，
タスクコンテキスト・OS割込み禁止状態・割込み優先度マスク全解除状態であ
る．

6.6.2 割込み要求ラインの属性の設定

(6-6-2-1) void x_config_int(InterruptNumber intno,
							AttributeType intatr,
							PriorityType intpri)

intnoで指定された割込み要求ラインの割込み属性を，intatrで指定された通
りに設定する．また，割込み優先度を，intpriで指定された値に設定する．

この関数は，標準の割込み管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．割込み管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

この関数は，ターゲット非依存部のカーネル初期化処理から呼び出されるた
め，カーネルの初期化処理（NMIを除くすべての割込みがマスクされている）
から呼び出せるように実装すればよい．

intatrとして設定できる割込み属性は次の通り．ATK2-SC1の場合は，intatrに
必ずENABLEが含まれる．

	ENABLE		0x01	割込み要求禁止フラグをクリア

この他に，ターゲット定義で割込み属性を追加してもよい．定義値は，ENABLE
使用している0ビット(0x01)以外のビットを使用する．
また，属性マクロをターゲット定義で追加する場合には，その属性値を決定し，
定義をtarget_kernel.h（または，そこからインクルードされるファイル）に
含める．また，ジェネレータテンプレートファイルから参照できるように，
target_def.csv（または，同等の役割を持つファイル）に含める．

指定された割込み番号が有効な値でない場合や，その割込み要求ラインに対し
て設定できない属性を指定した場合，設定できない割込み優先度を指定した場
合の動作は保証する必要がない．このようなケースは，ジェネレータでエラー
を検出すべきである．ジェネレータテンプレートファイルのターゲット非依存
部は，パス2のテンプレートファイルのターゲット依存部で定義する，
INTNO_CREISR2_VALID,INTNO_VALUD, TNUM_INTPRIを用いてエラーを検出するが，
標準の割込み属性（ENABLE）が設定できない場合や，設定できない属性や割込
み優先度が割込み要求ラインによって異なる場合には，ジェネレータテンプレ
ートファイルのターゲット依存部で検出しなければならない．

6.6.3 割込み管理機能の初期化処理の変更

(6-6-3-1) OMIT_INITIALIZE_INTERRUPT（オプション）

割込み管理機能の初期化処理をターゲット依存部で用意し，ターゲット非依存
部に含まれる標準の割込み管理機能の初期化処理を用いない場合には，このシ
ンボルをマクロ定義する．

このシンボルをマクロ定義すると，INTINIB，initialize_interrupt
の定義が，カーネルのターゲット非依存部から取り除かれる．また，
TNUM_INTNO，tnum_intno，intinib_tableの定義が，ジェネレータのパス2のテ
ンプレートファイルのターゲット非依存部によってOs_Lcfg.cに生成されなく
なる．

(6-6-3-2) void initialize_interrupt(void)（オプション）
(6-6-3-3) InterruptNumberType GET_INTNO(ISRCB *p_isrcb)（オプション）
(6-6-3-4) PriorityType GET_INTPRI(ISRCB *p_isrcb)（オプション）
(6-6-3-5) INTINIB（オプション）
(6-6-3-6) intinib_table（オプション）

OMIT_INITIALIZE_INTERRUPTをマクロ定義した場合には，これらをターゲット
依存部で用意する．
GET_INTNOは引数のISRCBに対応する割込み番号を返す関数またはマクロであ
る．
GET_INTPRIは引数のISRCBに対応する割込み優先度を返す関数またはマクロで
ある．
INTINIBは割込み番号に関する初期化情報を含む構造体の型である．
initinib_tableはISRIDをインデックスとするINTINIBの配列である．

また，OMIT_INITIALIZE_INTERRUPTをマクロ定義した場合には，ターゲット依
存部で用意したINTINIB構造体に以下のメンバー名を実装する．
(6-6-3-7) intno：割込み番号
(6-6-3-8) intpri：割込み優先度

6.6.4 デフォルトのC2ISR

(6-6-4-1) void default_int_handler(void)（オプション）

ジェネレータにより割込みハンドラのテーブルを生成する場合などには，割込
みハンドラを登録しなかった割込みハンドラ番号に対して，デフォルトの
C2ISRとして，default_int_handlerを登録する．

default_int_handlerは，標準のものをターゲット依存部で用意するが，ユー
ザが用意したもので置き換えられるように，OMIT_DEFAULT_INT_HANDLERをマク
ロ定義した場合には，ターゲット依存部で定義しないようにする．

6.6.5 カーネル管理外の割込み

カーネル管理外の割込みハンドラは，カーネル内の割込み出入口処理を経由せ
ずに実行するのが基本である．

ただし，すべての割込みで同じアドレスに分岐するプロセッサでは，カーネル
内の割込み出入口処理を全く経由せずにカーネル管理外の割込みハンドラを実
行することができないため，割込み出入口処理のなるべく早いタイミングで，
カーネル管理外の割込みであるかを判別し，処理内容を分ける必要がある．具
体的には，カーネル管理外の割込みの出入口処理では，タスク切換えを行う必
要がない．

カーネル管理外の割込みハンドラを実行する際に，カーネル内の割込み出入口
処理の一部分を経由する場合には，CPU例外が起こる可能性を極力減らすととも
に，CPU例外を起こす可能性がある場合には，その可能性をターゲット依存部
のユーザーズマニュアルに記載しなければならない．

6.6.6 DisableAllInterrupts/EnableAllInterruptsの処理内容の変更

(6-6-6-1) OMIT_STANDARD_DISALLINT（オプション）

標準で提供されているDisableAllInterrupts/EnableAllInterruptsを使わず
に，ターゲット依存部で定義したDisableAllInterrupts/EnableAllInterrupts
を使う場合は，OMIT_STANDARD_DISALLINTマクロをターゲット依存部で定義す
る．

6.7 スタックモニタリング

ディスパッチャとC2ISRの出入口処理でのスタックモニタリングでスタックオ
ーバーフローが検出された場合の処理は以下の通り．ATK2-SC1ではスタックオ
ーバーフロー検出時のcall_protectionhook_mainからはリターンしない．

----------------------------------------
#ifdef CFG_USE_STACKMONITORING
void
スタックオーバーフロー検出処理(void)
{
	if (C2ISRの出入口処理でのスタックモニタリング) {
		OS割込み禁止状態にする
	}
	if (タスクコンテキスト) {
		非タスクコンテキストに切り替える
	}
	call_protectionhook_main(E_OS_STACKFAULT);
}
#endif /* CFG_USE_STACKMONITORING */
----------------------------------------

6.8 CPU例外ハンドラ

CPU例外の出入口処理の方法はプロセッサによって大きく異なるが，おおよそ
の処理内容は次の通り．

----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	スクラッチレジスタをスタックに保存する
	if (OS割込み禁止状態でない and C1ISR実行中のCPU例外でない) {
		OS割込み禁止状態にする
	}

	ターゲット依存のCPU例外情報を取得する … (*j)

	if (全割込み禁止中のCPU例外でない) {
		全割込み禁止解除状態にする
	}

	カーネル起動していない場合は，無限ループ … (*g)

	割込み・例外のネスト回数をインクリメントする

	if (タスクコンテキストでCPU例外発生) {
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}

#ifdef CFG_USE_PROTECTIONHOOK
	ターゲット依存のCPU例外情報をスタックに退避する … (*a)
	ターゲット依存部のCPU例外情報をプロテクションフックから取得できるように準備する
#endif /* CFG_USE_PROTECTIONHOOK */

	call_protectionhook_main(E_OS_PROTECTION_EXCEPTION);

#ifdef CFG_USE_PROTECTIONHOOK
	ターゲット依存のCPU例外情報を復帰する … (*a)
#endif /* CFG_USE_PROTECTIONHOOK */

	割込み・例外のネスト回数をデクリメントする

	if (C1ISR実行中のCPU例外でない) {
		if (タスクコンテキストでCPU例外発生) {
			スタックをタスク用のスタックに戻し，タスクコンテキストに切
			り換える
		}
		OS割込み禁止解除状態にする
	}

	CPU例外処理からのリターン後に，CPU例外発生前の割込み禁止状態に戻る
	ように準備する											… (*k)
	スクラッチレジスタをスタックから復帰する
	CPU例外処理からのリターン
}
----------------------------------------

全割込み禁止状態でCPU例外が発生した場合は，全割込み禁止状態でプロテク
ションフックを呼び出す．

(*a)において，プロテクションフック実行前にCPU例外情報を退避し，
プロテクションフックを実行した後，退避したCPU例外情報を復帰する理由は，
CPU例外がネストして発生した場合に，CPU例外情報を正しく取得できるように
するためである．
CPU例外情報を保存復帰しない場合，CPU例外処理中(※1)にC1ISRが発生し，
そのC1ISR実行中にCPU例外が発生したとき(※2)，(※2)のCPU例外処理により，
(※1)のCPU例外情報が上書きされ，(※1)のCPU例外処理に戻ったとき，
(※1)のプロテクションフックから観測されるCPU例外情報が，(※2)のものと
なり，正しくない情報が取得されてしまう．

(*g)において，StartOS実行前および，StartOSによるカーネル起動中にCPU例
外が発生する場合があるため，call_protectionhook_mainを呼ぶ前にカーネル
起動フラグ(kerflg)によるカーネル起動判定を行う．カーネル起動前に発生
したCPU例外の場合，依存部でケアする必要がある．デフォルトは，無限
ループにしている．

(*j)において，全割り込み禁止解除前にターゲット依存のCPU例外情報を取得
する理由は次の通り．ターゲット依存のCPU例外情報を保存した後で，C1ISRの
割込みが発生し，C1ISR実行中にCPU例外が発生した場合に，ターゲット依存の
CPU例外情報が上書きされるためである．

(*k)において，全割込み禁止状態の場合は，CPU例外処理からのリターン後も
全割込み禁止が維持されるようにする．例外発生元へリターンするため，全割
込み禁止状態にする．

プロテクションフックを実行する際に経由する部分では，CPU例外が起こる可
能性を極力減らすとともに，CPU例外を起こす可能性がある場合（例えば，ス
クラッチレジスタをスタックに保存する時に，バスエラーなどのCPU例外が発
生する可能性が考えられる）には，その可能性をターゲット依存部のユーザー
ズマニュアルに記載しなければならない．

6.9 エラーフック，シャットダウンフック呼び出し

エラーフック，シャットダウンフックを呼び出す時に，非タスクコンテキスト
に切り替える処理をターゲット依存部で行う．

(6-9-1) void call_errorhook(StatusType ercd, OSServiceIdType svcid)

call_errorhookはエラーフックを呼び出す時にターゲット非依存部から呼び出
される．call_errorhookの処理内容は次の通り．

----------------------------------------

void
call_errorhook(StatusType ercd, OSServiceIdType svcid)
{
	if (タスクコンテキスト) {
		非タスクコンテキストに切り替える
	}
	internal_call_errorhook(ercd, svcid);
	元のコンテキストに戻す
}

----------------------------------------

(6-9-2) void call_shutdownhook(StatusType ercd)

call_shutdownhookはシャットダウンフックを呼び出す時にターゲット非依存
部から呼び出される．call_shutdownhookの処理内容は次の通り．

----------------------------------------

void
call_shutdownhook(StatusType ercd)
{
	if (タスクコンテキスト) {
		非タスクコンテキストに切り替える
	}
	internal_call_shutdownhook(ercd);
	元のコンテキストに戻す
}

----------------------------------------

6.10 カーネルの起動・終了とスタック領域など

(6-10-1) スタートアップモジュール

カーネルのスタートアップモジュールは，システムのリセット後に最初に実行
されるプログラムである．スタートアップモジュールは，標準的には，プロセ
ッサ依存部またはチップ依存部で用意し以下の処理を行うが，それにこだわる
必要はない．具体的には，開発環境に用意されているスタートアップモジュー
ルを用いる方法（この場合，ターゲット依存部でmain関数を用意する必要があ
る）や，アプリケーションで用意する場合が考えられる．

(a) プロセッサ状態の初期化

プロセッサモード，スタックポインタ，フレームポインタ等，プロセッサの状
態を初期化する．また，NMIを除くすべての割込みをマスクした状態（全割込
み禁止状態と同等の状態）とする．DRAMコントローラの初期化など，メモリを
アクセスするために必要な初期化処理をここで行ってもよい（次の
hardware_init_hookで行ってもよい）．

(b) hardware_init_hookを呼び出す

システムのリセット後すぐに行う必要のあるターゲットシステム依存の初期化
処理を行うために，hardware_init_hookを呼び出す．hardware_init_hookが用
意されていない場合は，何もしない．GNU開発環境では，リンカスクリプト中
のweak definitionにより，hardware_init_hookが用意されていない場合の値
を0とすることで，これを実現できる．weak definitionの機能を持たない開発
環境では，hardware_init_hookを必ず呼び出すことにする．

hardware_init_hookは，ターゲット依存部で用意するのが標準であるが，シス
テムのリセット後すぐに行う必要のある初期化処理を追加するために，アプリ
ケーションで用意したものを用いる場合もある．

メモリアクセスに必要な初期化処理をhardware_init_hookで行う場合には，こ
れを呼び出す時点でメモリにアクセスすることができないため，関数（サブル
ーチン）を呼び出すためにスタックを使用するプロセッサでは，戻り番地を汎
用レジスタに入れて呼び出すといった工夫が必要である．この場合，
hardware_init_hookをC言語で記述することはできなくなるが，やむをえない．

(c) bssセクションとdataセクションの初期化

bssセクションをクリアし，dataセクションに初期値を設定する．

ただし，カーネル本体は，以下にリストしている変数が0に初期化されること以
外に，これらのセクションが初期化されることに依存していないため，スター
トアップモジュールをアプリケーションで用意する場合で，ライブラリやアプ
リケーションがこれらのセクションが初期化されることに依存していない場合
には，システムの起動時間を短縮するために，これらのセクションの初期化を
省略することができる．下記リストの変数を0に初期化するだけで十分である．
・kerflg = 0(FALSE）
・sus_all_cnt = 0
・sus_all_cnt_ctx = 0
・sus_os_cnt = 0
・sus_os_cnt_ctx = 0
・callevel_stat = 0

(d) software_init_hookを呼び出す

開発環境（特にライブラリ）に依存して必要な初期化処理を行うために，
software_init_hookを呼び出す．software_init_hookが用意されていない場合
は，何もしない．GNU開発環境では，リンカスクリプト中のweak definitionに
より，software_init_hookが用意されていない場合の値を0とすることで，こ
れを実現できる．weak definitionの機能を持たない開発環境では，
software_init_hookを必ず呼び出すことにする．

software_init_hookは，ターゲット依存部で用意するのが標準である．

(e) target_hardware_initializeを呼び出す

カーネル起動前，ターゲットで事前に初期化する必要があるハードウェアを初
期化する．target_initialize()の前に必要なハードウェアの初期化を想定して
いる．上記のhardware_init_hookとの違いとして，hardware_init_hookは，シ
ステムのリセット後すぐに行う必要のあるターゲットシステム依存の初期化処
理で，target_hardware_initializeは，software_init_hookを呼出し後，main
関数を呼び出す前にターゲット依存のハードウェアを初期化する処理である．
システムタイマ機能を使用する場合，target_hardware_initializeでシステム
タイマの起動処理（target_timer_initialize）を行う．

target_hardware_initializeは，ターゲット依存部で用意するのが標準である．

(f) mainへ分岐

mainを呼び出す．mainの中でStartOSが呼ばれる．
mainからStartOS呼出した場合，mainから戻ってくることがないが，StartOSを
呼ばずにmainから戻ってくることがあるため，ケアする必要がある．方法とし
てはmainから戻ってきた場合，無限ループにすればよい．

(6-10-2) void target_initialize(void)

ターゲット依存部の初期化を行う関数．StartOSの最初で呼び出される．プロ
セッサ・チップ・開発環境依存の初期化処理を，それらの依存部に切り分ける
ことも可能である．

この関数は，あくまでもカーネルのターゲット依存部の初期化処理を行うため
のものである．アプリケーションに必要な初期化処理は，初期化ルーチンで行
うのが基本であるが，システムのリセット後すぐに行う必要がある場合には，
hardware_init_hookを用いる．

また，トレースログ機能を使う場合は，trace_initializeでトレースログ機能
を初期化する．

(6-10-3) void target_exit(void)

ターゲット依存部の終了処理を行う関数．この関数は，カーネル終了処理の最
後に呼び出され，リターンしてはならない．プロセッサ・チップ・開発環境依
存の終了処理を，それらの依存部に切り分けることも可能である．

この関数は，全割込み禁止状態で呼ばれるため，全割込み禁止状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

トレースログ機能を使う場合は，trace_dumpでログを出力する．

6.11 カーネル内部のチューニング

6.11.1 ビットマップサーチ

(6-11-1-1) OMIT_BITMAP_SEARCH（オプション）
(6-11-1-2) uint16 bitmap_search(uint16 bitmap)（オプション）

ターゲット非依存部で，uint16型の整数値（bitmap）中の1のビットの内，最
も下位（右）のものをサーチし，そのビット番号を返す関数bitmap_searchを
用意している．ここで，ビット番号は最下位ビットを0とし，bitmapに0を指定
してはならないものとしている．

ビットサーチ命令を持つプロセッサでは，bitmap_searchを，ビットサーチ命
令を使うように書き直した方が効率が良い場合がある．このような場合には，
ターゲット依存部でビットサーチ命令を使ったbitmap_searchを定義し，
OMIT_BITMAP_SEARCHをマクロ定義する．

標準ライブラリにビットサーチ命令を用いたffsがある場合，bitmap_searchを
(ffs(bitmap) - 1)に定義するとよい．

(6-11-1-3) uint16 PRIMAP_BIT(PriorityType pri)（オプション）

ビットサーチ命令のサーチ方向が逆などの理由で，優先度とビットとの対応を
変更したい場合には，PRIMAP_BITをマクロ定義する．

6.12 カーネル実装に関するその他の定義

6.12.1 エラーチェック方法の指定

(6-12-1-1) TARGET_MIN_STKSZ（オプション）

ターゲット定義で，タスクのスタックサイズの最小値を設定する場合には，こ
の変数をスタックサイズの最小値に定義する．

(6-12-1-2) CHECK_STKSZ_ALIGN（オプション）

スタック領域のサイズがある値（アライン単位）の倍数でなければならない場
合に，この変数をアライン単位に定義する．この変数を定義することで，
kernel.tfにおいて，スタック領域のサイズが正しくない（この変数に定義し
た値の倍数でない）場合のエラーをチェックするようになる．チェックが必要
ない場合には，この変数を定義しない．

(6-12-1-3) CHECK_FUNC_ALIGN（オプション）	処理単位のアライン単位
(6-12-1-4) CHECK_FUNC_NONNULL（オプション）処理単位の非NULLチェック
(6-12-1-5) CHECK_STACK_ALIGN（オプション）スタック領域のアライン単位
(6-12-1-6) CHECK_STACK_NONNULL（オプション）スタック領域の非NULLチェック

処理単位／スタック領域の先頭番地がある値（アライン単位）の倍数でなけれ
ばならない場合に，それぞれ，CHECK_FUNC_ALIGN／CHECK_STACK_ALIGNをアラ
イン単位に定義する．処理単位／スタック領域の先頭番地がNULLでないかのチェッ
クを行う場合には，それぞれCHECK_FUNC_NONNULL／CHECK_STACK_NONNULLを定
義する．

6.12.2 非タスクコンテキスト用のスタック領域

(6-12-2-1) MINIMUM_OSTKSZ

カーネルがStartOSの中でスタートアップフックを呼び出すまでに使うスタッ
ク使用量を指定する．

(6-12-2-2) StackType *TOPPERS_OSTKPT(sint8 *stk, MemorySizeType stksz)
          （オプション）

非タスクコンテキスト用のスタックポインタの初期値を保持する変数
（stkpt）を用いる場合に，このシンボルに，スタック領域の先頭番地
（stk）とスタック領域のサイズ（stksz）から，スタックポインタの初期値
を求めるマクロを定義する．

6.12.3 空ラベルの定義

(6-12-3-1) TOPPERS_EMPTY_LABEL(type, symbol)（オプション）

リンクエラーを防ぐために，データ型typeの配列である変数symbolに定義を与
えるためのマクロ．与えた定義が参照されることはないため，どのような定義
を与えてもよい．

デフォルトでは，symbolを，要素型がtypeでサイズが0の配列に定義している．
サイズが0の配列がエラーとならないコンパイラ（GCCはこれに該当）を用いる
場合には，ターゲット依存部で定義する必要はない．

6.12.4 各スタックのデフォルト値

ターゲット依存の各スタックのデフォルト値は，以下の定義を使用しているた
め，ターゲット依存部に定義する．また，ジェネレータテンプレートファイル
から参照できるように，target_def.csv（または，同等の役割を持つファイル）
に含める．

(6-12-4-1) DEFAULT_TASKSTKSZ（オプション）
(6-12-4-2) DEFAULT_ISRSTKSZ（オプション）
(6-12-4-3) DEFAULT_HOOKSTKSZ（オプション）
(6-12-4-4) DEFAULT_OSSTKSZ（オプション）

6.12.5 スタックマジックナンバー領域操作マクロの定義

(6-12-5-1) TOPPERS_ISTK_MAGIC_REGION(stk, stksz)（オプション）

スタックモニタリングで使用する割込みスタック用マジックナンバーの格納位
置を返すマクロであり，スタックの成長方向がアドレスの大きい方から小さい
方へ成長することをデフォルト実装としている．stkで指定しした割込みスタ
ック先頭番地とstkszで指定したスタックサイズを基づいて，スタック成長方
向によりターゲットで再定義することができる．

(6-12-5-2) TOPPERS_TSTK_MAGIC_REGION(p_tinib)（オプション）

スタックモニタリングで使用するタスクスタック用マジックナンバーの格納位
置を返すマクロであり，スタックの成長方向がアドレスの大きい方から小さい
方へ成長することをデフォルト実装としている．スタック成長方向によりター
ゲットで再定義することができる．p_tinibで指定ししたタスク初期化ブロック
を基づいて，スタック成長方向によりターゲットで再定義することができる．

(6-12-5-3) STACK_MAGIC_NUMBER（オプション）

スタックモニタリングで使用するスタックモニタリング用マジックナンバーの
定義マクロであり，デフォルト定義は，NCESのASCIIコード(0x4E434553)であ
る．ターゲットで再定義することができる．

6.13 トレースログ機能に関する設定

ATK2-SC1のソースコードには，カーネルの実行トレースログを取得するため
のマクロ等が埋め込んである．デフォルトでは，これらのマクロは空に定義さ
れてトレースログの取得は行わないが，これらのマクロを適切に定義すること
でトレースログの取得を行うことができる．

6.13.1 取得できるトレースログの種類とマクロ

取得できるトレースログの種類と，それを取得するために定義するマクロは次
の通りである．

(a) 処理単位の実行開始と終了

次のマクロを定義することで，C2ISR（ISR），アラーム満了処理（ALM），ス
ケジュールテーブル満了処理（SCHTBL），スタートアップフック（STAHOOK），
エラーフック（ERRHOOK），プロテクションフック（PROHOOK），シャットダウ
ンフック（SHUTHOOK）の実行開始前と終了後のトレースログを取得することが
できる．

	LOG_<処理単位略号>_ENTER	処理単位の実行開始直前
	LOG_<処理単位略号>_LEAVE	処理単位の終了直後

タスクの実行開始と終了は，他の方法で取得できるため，この方法は用意
していない．

(b) タスク状態の変化

次のマクロを定義することで，タスク状態が変化した時のトレースログを取得
することができる．ただし，実行状態と実行可能状態の間の遷移は，他の方法
で取得できるため，このマクロでは取得できない．

	LOG_TSKSTAT		タスク状態の変化

(c) ディスパッチャの実行開始と終了

次のマクロを定義することで，ディスパッチャが実行開始する時と，終了する
時のトレースログを取得することができる．

	LOG_DSP_ENTER	ディスパッチャの実行開始
	LOG_DSP_LEAVE	ディスパッチャの終了

ディスパッチャの実行開始は，タスクが実行状態から実行可能状態に遷移する
タイミングであるため，実行可能状態へ遷移するタスクのTCBへのポインタを
パラメータとする．逆に，ディスパッチャの終了は，タスクが実行可能状態か
ら実行状態に遷移するタイミングであるため，実行状態へ遷移するタスクの
TCBへのポインタをパラメータとする．

ATK2-SC1では，実行できるタスクがなく，カーネルがアイドル状態になる場
合には，ディスパッチャの中に留まる．そのため，アイドル状態への遷移とア
イドル状態から他の状態への遷移は，このマクロでは取得できない．

なお，ディスパッチャの実行開始と終了のトレースログ取得は，ターゲット依
存部で実装する必要がある．詳しくは，「6.2 トレースログ機能への対応」と
「6.5.2 ディスパッチャ本体」の節を参照すること．

(d) システムサービスの入口と出口

次のマクロを定義することで，各システムサービスの入口と出口のトレースロ
グを取得することができる．

	LOG_<システムサービスの大文字表記>_ENTER		システムサービス名
													の入口
	LOG_<システムサービスの大文字表記>_LEAVE		システムサービス名
													の出口

それぞれのマクロの名称やパラメータの詳細については，カーネルのソースコ
ードを参照すること．

6.13.2 トレースログ記録のサンプルコード

トレースログを記録する方法の一例として，メモリ上にトレースログを記録す
るためのサンプルコードをarch/logtraceディレクトリに用意している．この
サンプルコードは，システムログ機能と同様のトレースログ機能を用意し，ト
レースログ情報をメモリ上に記録するとともに，それを読み出して表示する機
能を実現している．

このサンプルコードを組み込む方法は次の通りである．

(1) target_config.hおよびtarget_sysmod.hに，次の記述を追加する．

	#ifdef TOPPERS_ENABLE_TRACE
	#include "logtrace/trace_config.h"
	#endif /* TOPPERS_ENABLE_TRACE */

(2) Makefile.targetに，次の記述を追加する．

	ifeq ($(ENABLE_TRACE),true)
		COPTS := $(COPTS) -DTOPPERS_ENABLE_TRACE
		KERNEL_DIR := $(KERNEL_DIR) $(SRCDIR)/arch/logtrace
		KERNEL_COBJS := $(KERNEL_COBJS) trace_config.o trace_dump.o
	endif

(3) スタートアップモジュールで，dataセクションの初期化を省略している場
    合には，trace_modeをTRACE_AUTOSTOP（＝2）に初期化するコードを追加
    する．

このサンプルコードを用いて，トレースログを記録・ダンプする方法について
は，「ATK2-SC1 ユーザーズマニュアル」の「10.5 トレースログ記録のサンプ
ルコードの使用方法」の節を参照すること．

6.14 ハードウェアカウンタ

AUTOSARでは，指定した時間で周期的にタスクを起動する使用方法が一般的であ
るため，1つ以上のハードウェアカウンタが必須である．ECUコンフィギュレー
ションを容易にするため，ハードウェアカウンタは，ポーティングの一部とし
てターゲット依存部で用意することを推奨する．

6.14.1 ハードウェアカウンタのファイル構成

ハードウェアカウンタを使用するためのコンフィギュレーションファイル(
target_hw_counter.arxml)を用意する．このファイルには，ハードウェアカウ
ンタの定義に加え，ハードウェアカウンタが使用するタイマ割込みのための
C2ISRの定義，ハードウェアカウンタ制御関数を含む．

ハードウェアカウンタを使用するために必要な定義を含むヘッダファイルを，
target_hw_counter.hに用意する．また，ハードウェアカウンタの実装ファイル
をtarget_hw_counter.cに用意する．

タイムティックの通知により行う処理の多くは，タスクの起動や待ち解除を行
うものであるため，タイマ割込みの割込み優先度は，割込みの中で最低の優先
度で十分である．

6.14.2 ハードウェアカウンタの情報提供

ハードウェアカウンタを使用する際，接続するアラーム，スケジュールテーブ
ルの参照先として記述するショートネーム，および1ティック当たりの秒数
(OsSecondsPerTick)をユーザに明示する．ユーザはこれらの情報からアラーム
によるタスクの周期起動を秒単位で設定できるようになる．なお，互換性向上
のため，"MAIN_HW_COUNTER"というハードウェアカウンタを用意することを推奨
する．
サンプルプログラムでは，MAIN_HW_COUNTERを使用し，10msと一致するティック
値を示すTICK_FOR_10MSマクロを使用するため，サンプルプログラムを使用する
には，これらを用意する．


７．ジェネレータ設定ファイルのターゲット依存部

7.1 設定ファイルとターゲット依存部の位置付け

ATK2-SC1のジェネレータは，設定ファイルの記述に従ってファイルの生成およ
びエラーチェックを行う．ジェネレータの設定ファイルには，以下の4つがあ
る．

(a) XMLコンテナテーブル

コンテナの一覧と，コンテナのパラメータについて記述したファイル．コンテ
ナ仕様を拡張する場合以外は変更する必要がないため，ターゲット非依存部で
用意している（kernel/kernel.csv）．

(b) 値取得シンボルテーブル

ジェネレータのパス1において，パラメータ計算用C言語ファイルに出力し，値
を求めたいシンボル（一般には式）を記述するためのファイル．ターゲット非
依存部では，ターゲットに依存せずに必要となるシンボルを記述したファイル
を用意している（kernel/kernel_def.csv）．

ターゲットに依存して必要となるシンボルがある場合には，targetディレクト
リに置かれたtarget_def.csv中に記述する．target_def.csv中に記述して値を
求めることができるシンボルは，kernel/kernel_int.hおよびそこからインク
ルードされるファイルで定義されていなければならない．kernel_int.hから
は，Platform_Types.h，Compiler.h, target_kernel.h，target_config.hを
（間接的に）インクルードしているため，これらのファイルおよびそこからイ
ンクルードされるファイルで定義されるターゲット依存のシンボルは，
target_def.csv中に記述することができる．

ここで値を求めたシンボルの値は，ジェネレータのパス2およびパス3のテンプ
レートファイル中で参照することができる．

(c) パス2のテンプレートファイル

ジェネレータのパス2は，テンプレートファイルに従って，カーネルの構成・
初期化ファイル（Os_Lcfg.c），構成・初期化ヘッダファイル（Os_Lcfg.h）な
どを生成する．このテンプレートファイルは，ターゲット非依存部とターゲッ
ト依存部に切り分けてあるが，他のファイルのターゲット依存部とは逆に，タ
ーゲット依存部からターゲット非依存部をインクルードする形になっている．

具体的には，targetディレクトリに置かれたtarget.tfで，必要な変数を定義
した後，テンプレートファイルのターゲット非依存部（kernel/kernel.tf）を
インクルードする．kernel.tfでは，カーネルのターゲット非依存部で使用す
る変数定義等を生成する．kernel.tfをインクルードした後，target.tfでは，
カーネルのターゲット依存部で使用する変数定義等を生成する．target.tfか
ら，プロセッサ依存部，チップ依存部を，開発環境依存部を切り分けてもよ
い．

(d) パス3のテンプレートファイル

ジェネレータのパス3は，テンプレートファイルに従って，XMLの一般定数式パ
ラメータのチェックを行う．このテンプレートファイルも，ターゲット非依存
部とターゲット依存部に切り分けてあり，ターゲット依存部からターゲット非
依存部をインクルードする形になっている．

具体的には，targetディレクトリに置かれたtarget_check.tfで，必要な変数
を定義した後，テンプレートファイルのターゲット非依存部
（kernel/kernel_check.tf）をインクルードする．kernel_check.tfでは，カ
ーネルのターゲット非依存部で初期化ブロックに出力した一般定数式パラメー
タのチェックを行う．kernel_check.tfをインクルードした後，
target_check.tfでは，ターゲットに依存するチェックを行う．
target_check.tfから，プロセッサ依存部，チップ依存部を，開発環境依存部
を切り分けてもよい．

なお，ジェネレータの詳細仕様と設定ファイルの記述方法については，別途
PDFファイルの形で配布している「TOPPERS新世代カーネル用コンフィギュレー
タ仕様」および「TOPPERS新世代カーネル用コンフィギュレータ内蔵マクロプロ
セッサ仕様」を参照すること．

7.2 パス2のテンプレートファイルのターゲット依存部

以下では，パス2のテンプレートファイルのターゲット依存部を記述する上で
必要な事項について説明する．

7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数

target.tfからkernel.tfをインクルードする前に，次の変数を定義しておかな
ければならない．

(7-2-1-1) INTNO_CREISR2_VALID		C2ISRで使用できる割込み番号
(7-2-1-2) INTNO_VALID				使用できる割込み番号
(7-2-1-3) TNUM_INTPRI				割込み優先度の数

INTNO_CREISR2_VALIDとINTNO_VALIDにはそれぞれC2ISRで使用できる割込み番
号とC1ISRで使用できる割込み番号のリストを定義する．TNUM_INTPRIはC1ISR
の最高優先度(正の値)を定義する．

(7-2-1-4) GENERATE_TSKINICTXB（オプション）

USE_TSKINICTXBをマクロ定義した場合，TSKINICTXBの初期化情報を生成するた
めテンプレートファイル関数GENERATE_TSKINICTXBを定義する．
GENERATE_TSKINICTXBには，タスクIDがパラメータとして渡される．

7.2.2 ターゲット非依存部で定義される変数

kernel.tfの中では次の変数が定義されるため，kernel.tfをインクルードした
後，target.tfの中でこれらを参照することができる．

(7-2-2-1) ISR.INTNO[isrid]		isridを対応するintnoに変換するための連
想配列
(7-2-2-2) INT.ISRID[intno]		intnoを対応するisridに変換するための連
想配列

7.3 パス3のテンプレートファイルのターゲット依存部

以下では，パス3のテンプレートファイルのターゲット依存部を記述する上で
必要な事項について説明する．

7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数

target_check.tfからkernel_check.tfをインクルードする前に，必要に応じ
て，次の変数を定義しておかなければならない．

(7-3-1-1) GET_STK_TSKINICTXB（オプション）

USE_TSKINICTXBをマクロ定義した場合，TINIBからスタック領域の先頭番地を
取り出すためのテンプレートファイル関数GET_STK_TSKINICTXBを定義する．
GET_STK_TSKINICTXBには，タスク初期化ブロック（TINIB）の先頭番地がパラ
メータとして渡される．CHECK_STACK_ALIGN，CHECK_STACK_NONNULLとも定義し
ない場合には，GET_STK_TSKINICTXBを定義する必要はない．

7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル

ジェネレータに関してターゲット依存に用意する必要があるファイルとして，
設定ファイル以外にcfg1_out.cをリンクするために必要なスタブの定義ファイ
ルがある．

ジェネレータのパス1では，XMLの整数定数式パラメータの値をCコンパイラを用
いて求めるために，cfg1_out.cを生成する．これをコンパイル，リンクしてオ
ブジェクトファイルを生成する際に，スタートアップモジュールから参照され
るシンボルの定義を与える必要がある．

この定義を与えるために，cfg1_out.cからターゲット依存部の
target_cfg1_out.hをインクルードしている．target_cfg1_out.h（または，そ
こからインクルードされるファイル）には，スタートアップモジュールから参
照されるシンボルのスタブの定義を含める．典型的には，以下のような定義を
含める必要がある．

----------------------------------------
int
main(void)
{
	return 0;
}

void hardware_init_hook(void)
{
}

StackType * const	_ostkpt = UINT_C(0x00);

const uint8			MAGIC_1 = UINT_C(0x12);
const uint16		MAGIC_2 = UINT_C(0x1234);
const uint32		MAGIC_4 = UINT_C(0x12345678);
----------------------------------------

また，ジェネレータを用いてオフセットファイル（offset.h）を生成する場合
には，そのための記述をtarget_cfg1_out.h（または，そこからインクルード
されるファイル）に追加する必要がある．詳しくは，「2.5.1 ジェネレータを
用いる方法」の節を参照すること．


８．システムモジュール等のターゲット依存部

8.1 システムモジュールのターゲット依存部

シリアルポート数やシステムログタスク関連の定数など，システムモジュール
の構成を決定するための定義をtarget_sysmod.hまたはそこからインクルード
されるファイル（プロセッサ・チップ・開発環境依存部で用意されるヘッダフ
ァイルなど）に含める．

8.2 システムログ機能のターゲット依存定義

システムログ機能を使用する場合，スタートアップモジュールのbssセクシ
ョンのクリアを省略している場合には，syslog_lowmask_notを0に初期化する
コードを追加する．これは，システムログ機能が初期化される前に出力された
ログ情報を，低レベル出力機能を用いて出力するためである．

ターゲット依存部で提供すべきシステムログ機能のための定義は次の通りであ
る．

(8-2-1) TCNT_SYSLOG_BUFFER

システムログ機能のログバッファのサイズを定義するマクロ．定義しない場合
のデフォルト値は64．

(8-2-2) void target_fput_log(char c)

システムログの低レベル出力のための文字出力関数．ターゲット依存の方法
で，引数cの文字を表示/出力/保存する．

この関数は，リエントラントに実装しなければならない．この関数内で排他制
御が必要な場合には，SILを用いて全割込み禁止状態にすること．また，全割
込み禁止状態で呼ばれる場合があるため，全割込み禁止状態から呼び出す
ことができない関数を呼ばないように実装しなければならない．

低レベル出力をシリアルポート経由で行う場合で，シリアルインタフェースド
ライバとポートを共用しないことが望ましいが，ポート数が足りないためにや
むをえず共用する場合には，両者が競合しないように注意が必要である．具体
的には，両者が同じ設定でシリアルI/Oデバイスを使うようにし，シリアルイ
ンタフェースドライバの動作中に低レベル出力が行われても差し支えないよう
に設計する．また，低レベル出力が動作開始後にシリアルインタフェースドラ
イバがシリアルI/Oデバイスを初期化すると，文字化けが起こる可能性がある
ため，共用するポートは，低レベル出力機能側で初期化し，シリアルインタフ
ェースドライバでは初期化しないようにするとよい．

なお，この関数の本体を，どのファイルに記述するかが問題になる．システム
サービスのターゲット依存部には，標準では，関数定義を記述するためのファ
イルを用意していない．ターゲット依存で用意してもよいが，例外的に，カー
ネル実装のターゲット依存モジュール（target_config.c）に記述してもよい．

8.3 シリアルインタフェースドライバのターゲット依存部

ターゲット依存部で提供すべきシリアルインタフェースドライバのための定義
は次の通りである．これらの定義は，別に指定がない限り，target_serial.h
またはそこからインクルードされるファイルに含め，必要なコンフィギュレー
ション情報をtarget_serial.arxmlに記述する．関数の実体が必要な場合には，
target_serial.c等のファイルを用意する．

シリアルインタフェースドライバの中で，ターゲットのシリアルI/Oデバイス
に依存する部分を，シリアルI/Oデバイスドライバと呼ぶ．

8.3.1 変数，データ型，管理関数

(8-3-1-1) void InitHwSerial(void)（オプション）

シリアルI/Oデバイスドライバの初期化処理．

(8-3-1-2) void TermHwSerial(void)（オプション）

シリアルI/Oデバイスドライバの終了処理．

(8-3-1-3) ISR(RxHwSerialInt)

シリアルI/OデバイスのC2ISR．target_serial.arxmlに，この関数を割込みサー
ビスルーチンとして登録するコンテナを含める．また，そのコンテナに必要な
シリアルI/Oデバイスの割込み番号などは，target_serial.hでマクロ定義する．

8.3.2 デバイスサービスルーチン

以下のデバイスサービルルーチンは，（少なくとも）シリアルI/Oポートから
の割込みがマスクされた状態で呼び出される．また，タスクコンテキスト，非
タスクコンテキストのいずれかで呼び出される場合もある（いずれで呼び出さ
れても動作するようにしなければならない）．

(8-3-2-1) boolean uart_getready(void)

シリアルI/Oポートから文字を受信したかチェックする関数．文字を受信して
いた場合，TRUEを返し，文字を受信していない場合にはFALSEを返す．

(8-3-2-2) uint8 uart_getchar(void)

シリアルI/Oポートから文字を読む関数．uart_getready受信したかをチェック
した上で呼び出される．文字受信チェックと文字受信データ同時に取得する
ターゲットの場合は，uart_getreadyで取得した文字を返す．

8.3.3 コールバックルーチン

ターゲット依存部は，必要なタイミングで，シリアルインタフェースドライバ
のターゲット非依存部に含まれる以下のコールバックルーチンを呼び出びださ
なければならない．

コールバックルーチンは，（少なくとも）シリアルI/Oポートからの割込みが
禁止された状態で，非タスクコンテキストとして呼び出す．

(8-3-3-1) void RxSerialInt(uint8 character)

受信通知コールバックルーチン．引数のcharacterには受信した文字を入れる．

8.4 カーネル起動メッセージの出力のターゲット依存定義

ターゲット依存部で提供すべきカーネル起動メッセージの出力のための定義は
次の通りである．

(8-4-1) TARGET_NAME

ターゲットの名称に定義する．

8.5 サンプルプログラムとテストプログラムのターゲット依存定義

ターゲット依存部で提供すべきサンプルプログラムおよびテストプログラムの
ための定義は次の通りである．これらの定義は，target_test.h（またはそれ
らからインクルードされるファイル）に含める．

(8-5-1) RAISE_CPU_EXCEPTION

CPU例外を発生させるC言語のプログラムを定義するマクロ．

8.6 実行時間分布集計モジュールのターゲット依存定義

実行時間分布集計モジュールの設定をターゲット依存部で変更する場合，ター
ゲット依存部で提供すべき実行時間分布集計モジュールのための定義は次の
通りである．これらの定義は，target_test.h（またはそこからインクルード
されるファイル）に含める．この他に，ターゲット依存で必要な初期化処理が
ある場合にも，ターゲット依存部に含める．

(8-6-1) HISTTIM（オプション）

実行時間計測用の時刻のデータ型を定義するマクロ．定義しない場合のデフォ
ルトはSystemTimeUsType．

(8-6-2) void HIST_GET_TIM(HISTTIM *p_time)（オプション）

実行時間計測用の現在時刻を*p_timeに取得する処理に定義するマクロ．定義
しない場合のデフォルトはget_utm．

(8-6-3) uint32 HIST_CONV_TIM(HISTTIM time)（オプション）

実行時間計測用の時刻の差（時間）を，実行時間分布集計用の値に変換する処
理に定義するマクロ．時刻が過去に戻ったかオーバフローしたかの区別がつか
ない場合には，最上位ビットが1の値（INT_MAXよりも大きい値）を返す．定義
しない場合のデフォルトは，timeをuint32にキャストする処理．

(8-6-4) void HIST_BM_HOOK(void)（オプション）

実行時間計測直前に行うべき処理に定義するマクロ．キャッシュのパージや
フィル，メモリバリア処理等を行いたい場合には，このマクロに定義する．
定義しない場合のデフォルトは，空の処理になる．

8.7 タイマドライバ

タイマドライバは，主にトレースログや性能評価等で時間を計測するために使
用することを想定しており，AUTOSARでは必須の機能ではない．

8.7.1 タイマドライバのファイル構成

タイマドライバを組み込むためのコンテナを記述したシステムコンフィギュレ
ーションファイルを，target_timer.arxmlに用意する．
このファイルには，タイマ割込みのためのC2ISRの定義，タイマドライバが操
作するソフトウェアカウンタの定義を含むことになる．

タイマドライバを呼び出すために必要な定義を含むヘッダファイルを，
target_timer.hに用意する．また，タイマドライバの実装ファイルを
target_timer.cに用意する．

タイムティックの通知により行う処理の多くは，タスクの起動や待ち解除を行
うものであるため，タイマ割込みの割込み優先度は，割込みの中で最低の優先
度で十分である．

8.7.2 ソフトウェアカウンタの定義

(8-7-2-1) SysTimerCnt

タイマドライバがC2ISRでIncrementCounterによりインクリメントするソフト
ウェアカウンタをtarget_timer.arxmlで定義する．

8.7.3 時間型の定義

(8-7-3-1) SystemTimeUsType
(8-7-3-2) SystemTimeMsType

マイクロ秒単位の時間を表す型SystemTimeUsTypeとミリ秒単位の時間を表す型
SystemTimeMsTypeをtarget_timer.hまたはそこからインクルードされるファイ
ルに定義する．

8.7.4 タイマの初期化・終了処理・割込み処理

(8-7-4-1) void target_timer_initialize(void)

タイマを初期化し，タイマ割込みを周期的に発生させる関数．

この関数は，スタートアップフックで呼ばれることを想定している．ただし，
トレースログ機能を使う場合(TOPPERS_ENABLE_TRACEマクロが定義されている
場合)はtarget_timer_initializeはターゲット依存部で呼ばれるため，スター
トアップフックからは呼ぶ必要はない．

(8-7-4-2) void target_timer_terminate(void)

タイマの動作を停止させ，タイマ割込みを発生しないようにする関数．

この関数は，シャットダウンフックで呼ばれることを想定している．

(8-7-4-3) ISR(target_timer_hdr)

タイマ割込みにより起動されるC2ISR．

target_timer_hdrは，標準的には次のように定義する．

----------------------------------------
void
target_timer_hdr(void)
{
	StatusType ercd;

	ercd = IncrementCounter(SysTimerCnt);

	if (ercd != E_OK) {
		エラーリターンする場合のエラー処理
	}
}
----------------------------------------

この関数は，target_timer.arxml中に記述するコンテナにより，C2ISRとしてカ
ーネルに登録することを想定している．

8.7.5 現在の時刻の取得

(8-7-5-1) SystemTimeUsType get_tim_utime(void)

トレースログ機能や実行時間分布集計モジュールを使う場合は，システム起動
時からの時刻をマイクロ秒単位で返すget_tim_utimeを実装する．


９．その他

9.1 ドキュメント

ターゲット依存部のユーザーズマニュアルを，target_user.txtに用意する．
プロセッサ・チップ・開発環境依存部のユーザーズマニュアルを切り分けても
よいし，ファイルが大きくなる場合には複数のファイルに分割してよいが，そ
の場合には，target_user.txt中にそれらのファイル名を記述すること．

ターゲット依存部のユーザーズマニュアルには，少なくとも次のような内容を
記述することが望ましい．

(1) 対応しているターゲットシステムの種類・構成，バージョン番号
	・ターゲットハードウェア（ボード等）の名称と対応している構成
	・ターゲット略称
	・ターゲット非依存部のバージョン番号
	・プロセッサ，チップ，開発環境依存部の構成とバージョン番号

(2) 使用する開発環境と動作検証した条件（バージョン，オプション等）
	・言語処理系（コンパイラ，アセンブラ，リンカ等）
	・デバッグ環境

(3) ターゲット定義事項の規定

(3-1) データ型に関する規定
	・void *型，uintptr型，sintptr型のサイズ

(3-2) 割込み処理に関する規定
	・割込み優先度の段階数（TNUM_INTPRIの値）
	・制限事項と拡張（ターゲット定義で使用できる割込み属性）
	・デフォルトの割込みハンドラ（default_int_handler）の有無と処理内容

(3-3) C1ISRの割込みに関する規定
	・C1ISRの出入口処理の書き方
	・C1ISRが実行開始される時のシステム状態とコンテキスト
	・C1ISRの終了時に行われる処理
	・カーネル内の割込み出入口処理で起こる可能性のあるCPU例外

(3-4) CPU例外処理に関する規定
	・カーネル内のCPU例外出入口処理で起こる可能性のあるCPU例外

(3-5) 性能評価用システム時刻の参照に関する規定
	・get_tim_utimeのサポートの有無，その制限事項

(3-7) その他
	・その他の制限事項
	・その他の拡張機能

(4) カーネルの起動／終了処理に関する情報
	・用意しているスタートアップモジュールの処理内容
	・スタートアップモジュールからhardware_init_hookを呼び出している場
	  合には，hardware_init_hookをアプリケーションで用意する場合の作成
	  方法や制限事項など

(5) メモリマップ
	・デフォルトのメモリマップ，その変更方法

(6) タイマドライバ関連の情報
	・タイムティックの周期，その変更方法
	・使用するリソース（タイマ）
	・タイマ割込みの割込み優先度の変更方法

(7) シリアルインタフェースドライバの情報
	・使用するリソース（SIOコントローラ）
	・通信パラメータ（ボーレート，ビット数，パリティの有無，ストップビ
	  ット）

(8) システムログ機能の情報
	・システムログの低レベル出力の実現方法
	・通信パラメータ（ボーレート，ビット数，パリティの有無，ストップビ
	  ット）

(9) システム構築手順

(10) ターゲットシステム固有の注意事項
	・タスクコンテキストに含まれるレジスタ，含まれないレジスタ

(11) 類似のターゲットにポーティングする開発者向けの参考情報

(12) ディレクトリ構成・ファイル構成

(13) バージョン履歴

また，必要に応じて，ターゲット依存部の設計メモを，target_design.txtに
用意する．プロセッサ・チップ・開発環境依存部に関する設計メモを切り分け
てもよいし，ファイルが大きくなる場合には複数のファイルに分割してもよい
が，その場合には，target_design.txt中にそれらのファイル名を記述するこ
と．


１０．リファレンス

10.1 ターゲット依存部のファイル一覧

標準的なターゲット依存部のファイル構成は次の通りである．

Makefile.target		Makefileのターゲット依存部（２章）．
target_offset.tf	オフセットファイル生成用テンプレートファイル（2.5.1
					節，オプション）

Compiler.h		    AUTOSAR共通定義（Std_Types.h）のターゲット依存部
Platform_Types.h    （３章）．アプリケーションとカーネルの両方からイン
					クルードされる．
target_sil.h		システムインタフェースレイヤのターゲット依
					存部（４章）．
target_kernel.h		カーネルAPI（Os.h）のターゲット依存部（５章）．
					アプリケーションとカーネルの両方からインクルードさ
					れる．

target_config.h		カーネル実装のターゲット依存部のヘッダファイル（６
					章）．カーネルのみからインクルードされる．
target_config.c		カーネル実装のターゲット依存部のC言語で記述される
					部分（６章，オプション）．
target_support.S	カーネル実装のターゲット依存部のアセンブリ言語で記
					述される部分（６章，オプション）．
target_timer.arxml	タイマドライバのシステムコンフィギュレーションファ
					イル（6.13節）．
target_timer.h		タイマドライバのヘッダファイル（6.13節）．カーネル
					のみからインクルードされる．
target_timer.c		タイマドライバの実装ファイル（6.13節，オプション）．
システム略称.h		ターゲットのハードウェア資源（割込みハンドラ番号や
					CPU例外ハンドラ番号，デバイスレジスタの番地など）の
					定義を含むヘッダファイル．アプリケーションとカーネ
					ルの両方からインクルードされる（６章，オプション）．

target_def.csv		ジェネレータの値取得シンボルテーブルのターゲット依
					存部（７章，オプション）．
target.tf			ジェネレータのパス2のテンプレートファイルのターゲッ
					ト依存部（7.2節）．
target_check.tf		ジェネレータのパス3のテンプレートファイル（7.3節）．
target_cfg1_out.h	cfg1_out.cのリンクに必要なスタブの定義ファイル（7.4
					節）．

target_sysmod.h		システムモジュールのターゲット依存定義（8.0節）．
target_serial.arxml	シリアルドライバのシステムコンフィギュレーションファ
					イル（8.3節）．
target_serial.h		シリアルドライバのヘッダファイル（8.3節）．シリアル
					ドライバのみからインクルードされる．
target_serial.c		シリアルドライバの実装ファイル（8.3節，オプション）．
target_test.arxml	テストプログラムのターゲット依存定義のコンフィギュ
					レーションファイル（8.4節）．
target_test.h		テストプログラムのターゲット依存定義のヘッダファイル
					（8.4節）．
target_test.c		テストプログラムのターゲット依存定義実装ファイル
					（8.4節）．

target_user.txt		ユーザーズマニュアル（9.1節）
target_design.txt	設計メモ（9.1節，オプション）
MANIFEST			個別パッケージに含めるファイルのリスト

以上
