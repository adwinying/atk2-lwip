
		TOPPERS/ATK2-SC1
		ユーザーズマニュアル

このドキュメントは，TOPPERS/ATK2-SC1を使用するために必要な事項を説明
するものである．

----------------------------------------------------------------------
TOPPERS ATK2
    Toyohashi Open Platform for Embedded Real-Time Systems
    Automotive Kernel Version 2

Copyright (C) 2011-2015 by Center for Embedded Computing Systems
            Graduate School of Information Science, Nagoya Univ., JAPAN
Copyright (C) 2011-2015 by FUJI SOFT INCORPORATED, JAPAN
Copyright (C) 2011-2013 by Spansion LLC, USA
Copyright (C) 2011-2015 by NEC Communication Systems, Ltd., JAPAN
Copyright (C) 2011-2015 by Panasonic Advanced Technology Development Co., Ltd., JAPAN
Copyright (C) 2011-2014 by Renesas Electronics Corporation, JAPAN
Copyright (C) 2011-2015 by Sunny Giken Inc., JAPAN
Copyright (C) 2011-2015 by TOSHIBA CORPORATION, JAPAN
Copyright (C) 2011-2015 by Witz Corporation
Copyright (C) 2014-2015 by AISIN COMCRUISE Co., Ltd., JAPAN
Copyright (C) 2014-2015 by eSOL Co.,Ltd., JAPAN
Copyright (C) 2014-2015 by SCSK Corporation, JAPAN

上記著作権者は，以下の (1)〜(3)の条件を満たす場合に限り，本ドキュメ
ント（本ドキュメントを改変したものを含む．以下同じ）を使用・複製・改
変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
(1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
    および下記の無保証規定が，そのままの形でドキュメント中に含まれて
    いること．
(2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
    を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
    ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
    りではない．
(3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
    からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
    本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
    く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

本ドキュメントは，AUTOSAR（AUTomotive Open System ARchitecture）仕様
に基づいている．上記の許諾は，AUTOSARの知的財産権を許諾するものではな
い．AUTOSARは，AUTOSAR仕様に基づいたソフトウェアを商用目的で利用する
者に対して，AUTOSARパートナーになることを求めている．

本ドキュメントは，無保証で提供されているものである．上記著作権者およ
びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
により直接的または間接的に生じたいかなる損害に関しても，その責任を負
わない．

$Id: user.txt 1801 2015-03-27 06:34:43Z t_ishikawa $
----------------------------------------------------------------------

○目次

１．TOPPERS/ATK2-SC1の概要
	1.1 TOPPERS/ATK2-SC1の位置付け
	1.2 TOPPERS/ATK2-SC1の仕様
	1.3 既知の問題
	1.4 Cygwin環境における注意事項
２．ターゲット依存部
	2.1 ターゲット依存部の概要
３．クイックスタートガイド
	3.1 開発環境の準備
	3.2 ジェネレータの構築
	3.3 XMLスキーマの入手
	3.4 サンプルプログラムの構築と実行
	3.5 カーネルを関数単位でライブラリ化する方法
	3.6 アプリケーションとカーネルを別々に構築する方法
	3.7 カウンタの循環チェックの省略
	3.8 Rte_Type.hの用意
４．ディレクトリ構成・ファイル構成
	4.1 配布パッケージのディレクトリ構成
	4.2 ターゲット非依存部のファイル構成
５．コンフィギュレーションスクリプトの使い方
６．Makefileの修正方法
	6.1 Makefileの変数定義
	6.2 コンパイルオプション
７．ジェネレータの使い方
	7.1 コンフィギュレーションファイル(arxml)
８．システムモジュール
	8.1 システムログ機能
		8.1.1 低レベル出力
		8.1.2 ログ情報の種別
		8.1.3 ログ情報の重要度
		8.1.4 ログ情報のデータ構造
		8.1.5 システムログ機能のサービスコール
		8.1.6 システムログ機能のためのライブラリ関数とマクロ
		8.1.7 システムログ機能のその他のサービス
	8.2 シリアルインタフェースドライバ
		8.2.1 シリアルインタフェースドライバのサービスコール
	8.3 カーネル起動メッセージの出力
９．サポートライブラリ
	9.1 基本的なライブラリ関数
	9.2 キュー操作ライブラリ関数
	9.3 システムログ出力用ライブラリ関数
	9.4 実行時間分布集計モジュール
１０．使用上の注意とヒント
	10.1 タイマドライバの組込み
	10.2 ASSERTマクロの処理
	10.3 システムログ機能の扱い
	10.4 オブジェクトIDの管理
	10.5 トレースログ記録のサンプルコードの使用方法
	10.6 システムの起動時の初期化処理
	10.7 想定するプログラミング言語
	10.8 ユーザスタック領域定義
	10.9 スタックサイズを見積もる際の注意点
	10.10 スタートアップ/シャットダウンフック無効時の注意点
	10.11 システムタイマの使用方法
１１．参考情報
	11.1 利用条件と利用報告
	11.2 保証・適用性・サポート
	11.3 バグレポート
	11.4 ウェブサイト
	11.5 TOPPERSユーザーズメーリングリスト
	11.6 TOPPERSプロジェクトのメンバ向けのサービス
	11.7 TOPPERSプロジェクトへの参加


１．TOPPERS/ATK2-SC1の概要

1.1 TOPPERS/ATK2-SC1の位置付け

TOPPERS/ATK2-SC1は，AUTOSAR OS仕様のSC1をベースとして，名古屋大学組込
みシステム研究センター(NCES)が，複数の企業と共同で開発し,TOPPERSプロジ
ェクトより公開するリアルタイムカーネルである．

1.2 TOPPERS/ATK2-SC1の仕様

ATK2-SC1の仕様については，「次世代車載システム向けRTOS外部仕様書」を
参照すること．

1.3 既知の問題

Os_Lcfg.c（およびcfg1_out.c）は，カーネル，システムモジュール，アプリ
ケーションのいずれのインクルードファイルもインクルードし，いずれのシン
ボルも参照する可能性がある．そのため，カーネル，システムモジュール，ア
プリケーションでシンボル等が衝突している場合や，コンパイルオプションが
食い違っている場合に，Os_Lcfg.c（およびcfg1_out.c）が正しくコンパイル
できなくなる場合が考えられる．

システムコンフィギュレーションファイルから，ジェネレータに対する
INCLUDEディレクティブにより他のコンフィギュレーションファイルをインク
ルードしている場合に，その中に含まれるC言語プリプロセッサのインクルー
ドディレクティブ（#include）で，コンフィギュレーションファイルの置かれ
ているディレクトリが，ファイルを検索するパスにはいらないという問題があ
る．

現時点では，アドレスが64ビットの環境には対応していない．64ビットアドレ
ス環境をサポートするための最大の課題は，モトローラSレコードフォーマッ
トが64ビットアドレスに対応していないことである．

エラーフック機能のON/OFFを実現するため，各エラーフックを呼び出している
システムサービスにおいて，ラベルの再定義を行っている．エラーフック機能
ONで，拡張エラー機能OFFにした場合，コンパイラーは，未使用ラベルの警告が
出る可能性がある．gccコンパイラの場合，オプション(-Wno-unused-label)で
警告を抑止することができる．また，すべてのラベルを#ifdefを囲んで上記オ
プション無くすことができるが，ソースコードの可読性が落ちるので，オプシ
ョンで警告を抑止している．このオプションにより，ユーザアプリの未使用ラ
ベルの警告も抑止される問題がある．

1.4 Cygwin環境における注意事項

Cygwin環境においては，ディレクトリの指定を相対パスで行うことを推奨する．
これは，Cygwin環境の絶対パスは，Windowsネイティブでビルドされたツールは
解釈できないためである．


２．ターゲット依存部

2.1 ターゲット依存部の概要

ATK2-SC1を未サポートのターゲットシステムへポーティングするために必要
な作業は，開発環境の構築と標準の開発環境との差異の吸収，カーネル自身の
ポーティング，ライブラリのポーティングなどからなる．詳しくは，
「ターゲット依存部 ポーティングガイド」を参照すること．


３．クイックスタートガイド

ここでは，ターゲット依存部が用意されているターゲットシステム上で，
ATK2-SC1上で動作するサンプルプログラムを構築・動作させるまでの手順を示
す．

3.1 開発環境の準備

ATK2-SC1を用いたシステム構築には，以下のツールが必要である．

	ホストシステム用のツール
		perl		動作確認：5.10.0
		GNU Make	動作確認：3.81

	TOPPERS新世代カーネル用コンフィギュレータ(ジェネレータと呼ぶ)
		cfg			動作確認：1.9.4

	ターゲットシステム用のツール（クロス開発環境）
		標準規格に準拠したCコンパイラ
		アセンブラ，リンカ，ライブラリアン
		シンボルファイル出力ツール，ヘキサファイル出力ツール
		標準Cライブラリ（必須ではない）

ターゲットシステム用のツールにGNU開発環境を用いる場合には，以下のツー
ルが必要である．

	ターゲットシステム用のGNU開発環境ツール
		BINUTILS（as，ld，ar，nm，ranlib，objcopy，objdump）
		GCCまたはGCC-CORE（gccおよびそこから呼び出されるツール）
		NEWLIB（標準Cライブラリ，必須ではない）

動作確認されているターゲットシステム用のツールについては，ターゲット依
存部のユーザーズマニュアルを参照すること．

ターゲットシステム用の標準Cライブラリは，アプリケーションが標準Cライブ
ラリを使用しない場合には，必要ない．ただし，コンパイラが標準Cライブラ
リ関数（memcpy，memsetなど）を呼び出すコードを生成する場合があり，その
場合には標準Cライブラリが必要である．標準Cライブラリを用意する代わり
に，生成したコードが呼び出す関数のみを自分で用意してもよい．

以下では，これらのツールが用意できていることを前提に，UNIXマシン上での
構築手順を説明する．また以下の説明では，makeコマンドがGNU Makeであるも
のとする（ATK2-SC1のサンプルのMakefileは，GNU Makeの拡張機能を用いて
いる）．

3.2 ジェネレータの構築

カーネルを構築する前に，まず，TOPPERS新世代カーネル用コンフィギュレー
タを構築する必要がある．

ジェネレータの構築には，以下のツールが必要である．
Windows上(Cygwin含む)でジェネレータを動作させる場合はTOPPERSで公開して
いるWindows用バイナリをつかってもよい．

	ホストシステム用のツール（セルフ開発環境）
		C++コンパイラ，C++ライブラリ
					動作確認（Mac OS X環境）：GNU C++ 4.5.3
		Boost		動作確認：1.48.0
		GNU Make	動作確認：3.81

最初に，パッケージにジェネレータのソースファイルが含まれていない場合に
は，ジェネレータのパッケージを，ATK2-SC1のソースファイルを展開したディ
レクトリの下に展開する．

	% cd atk2-sc1

または，ジェネレータのパッケージを他のディレクトリに展開し，ATK2-SC1の
ソースファイルを展開したディレクトリからシンボリックリンクを
はってもよい．

ソースファイルが展開できると，cfgディレクトリに移動し，コンフィギュレ
ーションスクリプト（configure）でMakefileの環境依存部
（Makefile.config）を生成した後，makeコマンドによりジェネレータ（cfgプ
ログラム）が構築できる．

	% cd cfg
	% ./configure
	% make

ただし，Boostをインストールしたディレクトリおよび名称が標準で想定して
いるものとは違う場合には，configureの--with-headersおよび
--with-librariesオプションにより，ヘッダファイルおよびライブラリの置か
れたディレクトリを指定する必要がある．

また，ホストシステムによっては，最適化レベルを上げると正しくコンパイル
できないことが知られている．そのような場合には，最適化レベルを下げる
か，最適化を抑止するように，Makefileを修正する必要がある．

なお，ジェネレータの使用方法については，「７．ジェネレータの使い方」の
章で説明する．

ビルドしたcfg.exeはatk2-sc1/cfg/cfg/cfg.exeに配置する．

3.3 XMLスキーマの入手

XMLを使ってコンフィギュレーションを行うには以下のXMLスキーマを入手し，
atk2-sc1/cfg/cfg(3.2でビルドしたcfg.exeと同一フォルダ)に配置する．
・AUTOSAR_4-0-3_STRICT.xsd
・xml.xsd

AUTOSAR_4-0-3_STRICT.xsdとxml.xsdはautosar.orgで以下のメニューから取得
する．
Home | Specifications | Release 4.0 | Methodology and Templates |
Templates | Standard Specifications | AUTOSAR MMOD XMLSchema
・AUTOSAR_MMOD_XMLSchema.zip

3.4 サンプルプログラムの構築と実行

次に，ATK2-SC1上で動作するサンプルプログラムを構築する方法を説明する．

まず，サンプルプログラムのオブジェクトファイルを置くディレクトリを作成
し，コンフィギュレーションスクリプトを実行する．例えば，オブジェクトフ
ァイルを置くディレクトリを，ATK2-SC1のソースファイルを展開したディレ
クトリの下のOBJという名称のディレクトリにする場合には，次のコマンドを
実行する（ディレクトリの場所と名称は任意に決めてよい）．

	% cd atk2-sc1
	% mkdir OBJ
	% cd OBJ
	% perl ../configure -T <ターゲット略称>

ここで，<ターゲット略称>は，targetディレクトリの下に置かれているターゲ
ット依存部ディレクトリの名称である．コンフィギュレーションスクリプトの
オプションについては，「５．コンフィギュレーションスクリプトの使い方」
の章で説明する．

コンフィギュレーションスクリプトの実行により，カレントディレクトリに
は，サンプルプログラムを構築するためのMakefile，サンプルプログラム用の
コンフィギュレーションファイル（sample1.arxml），サンプルプログラム本
体（sample1.hおよびsample1.c）が生成される．

コンフィギュレーションスクリプトの実行後，必要であればMakefileを修正す
る．Makefileの修正方法については，「６．Makefileの修正方法」の章で説明
する．

その後，make dependで依存関係ファイル（Makefile.depend）を生成した後，
makeコマンドによりサンプルプログラムのロードモジュール（atk2-sc1または
atk2-sc1.exe）が生成できる．依存関係ファイルの生成には若干時間がかかる．

	% make depend
	% make all

ここで構築したサンプルプログラム（sample1.h，sample1.c，sample1.arxml）
は，ATK2-SC1の基本的な動作を確認するためのものである．
このプログラムの概要説明は，sample1.cの先頭のコメントにある．
また，ターゲットによって，ターゲット依存部にtarget_user.txtが用意されて
いる場合がある．デバッグ方法などの情報についてtarget_user.txtをご参照く
ださい．

3.5 カーネルを関数単位でライブラリ化する方法

前節の手順では，カーネルをファイル単位でコンパイルし，ライブラリ化して
いたが，カーネルのコードサイズを縮小するためには，使用しないサービスコー
ルはリンクしない方が望ましい．そこでATK2-SC1では，カーネルを関数単位
でコンパイルし，ライブラリ化する方法を用意している．

この方法でサンプルプログラムを構築するには，コンフィギュレーションスク
リプトに，それを指示するオプション（-f）を付加するだけでよい．

	% mkdir OBJ_LIB
	% cd OBJ_LIB
	% perl ../configure -T <ターゲット略称> -f

ここで，OBJ_LIBというディレクトリの場所と名称は，任意に決めてよい．こ
れ以降の手順は，前節と同じである．

3.6 アプリケーションとカーネルを別々に構築する方法

前節で説明した方法では，アプリケーションとカーネルを同時に生成するた
め，オブジェクトファイルを置くディレクトリに非常に多くのファイルが作成
されて，扱いにくくなる．そこで，カーネルを修正する頻度が低い場合には，
カーネルは事前に構築しておき，後でアプリケーションだけを構築する方法を
用意している．以下では，サンプルプログラムを構築を例に，その手順につい
て説明する．

まず，カーネルを構築するディレクトリを作成し，コンフィギュレーションス
クリプトを実行する．例えば，カーネルを構築するディレクトリを，ATK2-SC1
のソースファイルを展開したディレクトリの下のKERNEL_LIBという名称の
ディレクトリにする場合には，次のコマンドを実行する（ディレクトリの場所
と名称は任意に決めてよい）．

	% mkdir KERNEL_LIB
	% cd KERNEL_LIB
	% perl ../configure -T <ターゲット略称> -f

これにより，カーネルを構築するディレクトリに，Makefile，sample1.arxml,
 sample1.h，sample1.cが生成される．

make dependで依存関係ファイル（Makefile.depend）を生成した後，
make libkernel.aによりカーネルライブラリ（libkernel.a）が生成できる．

	% make depend
	% make libkernel.a

次に，アプリケーションを構築するディレクトリを作成し，コンフィギュレー
ションスクリプトを実行する．例えば，アプリケーションを構築するディレク
トリを，ATK2-SC1のソースファイルを展開したディレクトリの下のAPLという
名称のディレクトリにする場合には，次のコマンドを実行する（ディレクトリ
の場所と名称は任意に決めてよい）．

	% cd ..
	% mkdir APL
	% cd APL
	% perl ../configure -T <ターゲット略称> -L ../KERNEL_LIB

ここで-Lオプションには，カーネルを構築したディレクトリのパスを指定す
る．

最後に，make dependで依存関係ファイル（Makefile.depend）を生成した後，
makeコマンドによりサンプルプログラムのロードモジュール（atk2-sc1または
atk2-sc1.exe）が生成できる．

	% make depend
	% make all

この手順では，アプリケーション構築時にはカーネルの再構築が必要かチェッ
クしないため，カーネルのソースコードを修正した場合には，カーネルを構築
したディレクトリでmake libkernel.aを再実行する必要がある．

また，libkernel.aをビルドしたときに生成されるOs_Cfg.hの内容とアプリケ
ーションをビルドしたときに生成されるOs_Cfg.hの内容は一致している必要が
ある．一致していない場合はエラーが検出される．Os_Lcfg.cとOs_Lcfg.hは
libkernel.aのビルドには影響しないため，libkernel.aのビルド時とアプリケ
ーションのビルド時でこれらのファイルが一致していなくても問題ない．

以上では，カーネルとアプリケーションを別々のディレクトリで構築したが，
-Lオプションにカレントディレクトリ（ただし，"."という記述では不可）を
指定することで，カーネルとアプリケーションを同じディレクトリで別々に構
築することもできる．具体的には，次の手順となる．

	% mkdir OBJ
	% cd OBJ
	% perl ../configure -T <ターゲット略称> -L ../OBJ
	% make depend
	% make libkernel.a
	% make cleankernel
	% make

ここで，make cleankernelは，カーネルライブラリを生成するための中間ファ
イルを削除するものである．この手順では，make dependによりカーネルライ
ブラリに関する依存関係を生成しないため，カーネルのソースコードを修正し
た場合には，必ずmake cleankernel（または，make clean）してから，make
libkernel.aする必要があるので注意すること．

なお，make realcleanすると，make dependとmakeにより生成したファイルを
すべて削除する．それに対して，make cleanでは，make dependにより生成し
た依存関係ファイルは削除しない．

3.7 カウンタの循環チェックの省略

コンフィギュレーション時に，カウンタが循環していなかのチェックを行う
が，カウンタの数が多い場合に時間がかかることがある．
OMIT_CHECK_CYCLIC_CHAINをアプリケーションのヘッダファイル(sample1.hに
相当するヘッダファイル)に定義することで，この循環チェックを省略するこ
とができる．

3.8 Rte_Type.hの用意

AUTOSARではシステム全体で使用するデータ型を統合して定義する仕組みがあり，
定義したデータ型は，RTEジェネレータによって，Rte_Type.hに出力される．し
たがって，OSからシステム全体で使用するデータ型を使用するために，
Rte_Os_Type.hから，Rte_Type.hをincludeする．RTEジェネレータを使用しない
場合や，システム全体で使用するデータ型を使用しない場合は，空の
Rte_Type.hを用意する．


４．ディレクトリ構成・ファイル構成

4.1 配布パッケージのディレクトリ構成

	include/		アプリケーション向けヘッダファイル
	kernel/			カーネルソースファイル
	sysmod/			システムモジュールヘッダファイル，ソースファイル
	library/		サポートライブラリソースファイル
	target/			ターゲット依存部
	arch/			ターゲット依存部の共通部分
		gcc/		GCC開発環境依存部
		logtrace/	トレースログ記録のサンプルコード
	utils/			ユーティリティプログラム
	sample/			サンプルプログラムとMakefile
	doc/			ドキュメント

4.2 ターゲット非依存部のファイル構成

ターゲット非依存部の各ファイルの概要は次の通り．

	README.txt			TOPPERS/ATK2-SC1の簡単な紹介
	configure			コンフィギュレーションスクリプト
						（GNU開発環境用）
	MANIFEST			個別パッケージのファイルリスト

	include/
		Os.h			ATK2-SC1を使用するための定義
		Std_Types.h		AUTOSAR共通ヘッダファイル
		MemMap.h		AUTOSARで規定されているヘッダファイル
		t_syslog.h		システムログ出力を行うための定義
		t_stdlib.h		基本的なライブラリ関数を使用するための定義
		queue.h			キュー操作ライブラリを使用するための定義
		histogram.h		実行時間分布集計モジュールを使用するための定義
		log_output.h	システムログのフォーマット出力を使用するための
						定義
		kernel_fncode.h	システムサービスの番号を定義しているヘッダファ
						イル
		Rte_Os_Type.h	BSW及びソフトウェアコンポーネント共通の型定義

	kernel/
		Makefile.kernel		カーネルのファイル構成の定義
		kernel_impl.h		カーネル実装用標準ヘッダファイル
		kernel_int.h		Os_Lcfg.c用のヘッダファイル
		kernel.csv			ジェネレータのXMLコンテナテーブル
		kernel_def.csv		ジェネレータの値取得シンボルテーブル
		kernel.tf			ジェネレータのパス2のテンプレートファイル
		kernel.ini			XMLを用いたジェネレータ設定ファイル
		kernel_check.tf		ジェネレータのパス3のテンプレートファイル
		genoffset.tf		オフセットファイル生成用のテンプレートフ
							ァイル
		allfunc.h			すべての関数をコンパイルするための定義
		check.h				エラーチェック用マクロ
		task.h				タスク操作ルーチン関連の定義
		task.c				タスク操作ルーチン
		task_manage.c		タスク管理機能
		alarm.h				アラームハンドラ機能関連の定義
		alarm.c				アラームハンドラ機能
		counter.h			カウンタ機能関連の定義
		counter.c			カウンタ機能の内部関数
		counter_manage.c	カウンタ機能のシステムサービス
		event.h				イベント機能関連の定義
		event.c				イベント機能
		interrupt.h			割込み管理機能関連の定義
		interrupt.c			割込み管理機能の内部関数
		interrupt_manage.c	割込み管理機能のシステムサービス
		resource.h			リソース機能関連の定義
		resource.c			リソース機能
		scheduletable.h		スケジュールテーブル機能関連の定義
		scheduletable.c		スケジュールテーブル機能
		osctl.c				OS起動終了の内部関数
		osctl_manage.c		OS起動終了のシステムサービス

	sysmod/
		banner.h		カーネル起動メッセージの出力のための定義
		banner.c		カーネル起動メッセージの出力
		serial.h		シリアルインタフェースドライバを使用するための
						定義
		serial.c		シリアルインタフェースドライバ
		syslog.h		システムログ機能を使用するための定義
		syslog.c		システムログ機能

	library/
		histogram.c		実行時間分布集計モジュール
		log_output.c	システムログのフォーマット出力
		strerror.c		エラーメッセージ文字列を返す関数
		t_perror.c		エラーメッセージの出力
		vasyslog.c		可変数引数のシステムログライブラリ

	arch/gcc/
		MANIFEST		個別パッケージのファイルリスト
		Compiler.h		AUTOSARで規定されているコンパイラ依存定義ファ
						イル
		Compiler_Cfg.h	AUTOSARで規定されているコンパイラ依存定義ファ
						イル

	arch/logtrace/
		MANIFEST		個別パッケージのファイルリスト
		trace_config.h	トレースログに関する設定
		trace_config.c	トレースログ機能
		trace_dump.c	トレースログのダンプ

	utils/
		applyrename		ファイルにリネームを適用
		genrename		リネームヘッダファイルの生成
		gentest			テストプログラムの生成
		makedep			依存関係リストの生成（GNU開発環境用）
		makerelease		リリースパッケージの生成

	sample/
		Makefile		サンプルのMakefile（GNU開発環境用）
		sample1.h		サンプルプログラム(1)に関する定義
		sample1.c		サンプルプログラム(1)
						ファイル
		sample1.arxml	サンプルプログラム(1)のコンフィギュレーション
						ファイル

	doc/
		user.txt					ユーザーズマニュアル
		porting.txt					ターゲット依存部 ポーティングガイド
		version.txt					変更履歴


５．コンフィギュレーションスクリプトの使い方

コンフィギュレーションスクリプト（configure）は，ATK2-SC1およびアプ
リケーションプログラムを構築するために必要な基本的なコンフィギュレーシ
ョンを行うためのプログラムである．

ATK2-SC1を用いてアプリケーションを作成する場合には，まずオブジェクトフ
ァイルを置くディレクトリを作成し，そのディレクトリでコンフィギュレーシ
ョンスクリプトを実行する．オブジェクトファイルを置くディレクトリの場所
と名称は，任意に決めてよい．

コンフィギュレーションスクリプトに対するオプションは次の通り．

	-T <ターゲット略称>
		ターゲットシステムの名称を，targetディレクトリの下に置かれてい
		るターゲット依存部ディレクトリの名称で指定する（必須）．

	-C <ファイル名>
		コンフィギュレーションファイル名称を指定する．省略した場合に
		は，アプリケーションプログラム名と同名になる．コーテーションで
		囲み，複数指定することで，すべてのコンフィギュレーションファイ
		ルを入力することができる．

	-A <アプリケーションプログラム名>
		アプリケーションプログラムの名称を指定する．省略した場合には，
		サンプルプログラム（sample1）となる．

	-a <アプリケーションのディレクトリ名>
		アプリケーションプログラムのソースファイル（システムコンフィギ
		ュレーションファイルを除く）を置いたディレクトリ名を指定する．
		省略した場合には，オブジェクトファイルを置くディレクトリに置か
		れていることを仮定する．システムコンフィギュレーションファイル
		は，オブジェクトファイルを置くディレクトリに置くこと．

	-U <オブジェクトファイル名>
		アプリケーションプログラムのメインのオブジェクトファイル（-A 
		で指定したアプリケーションプログラム名に".o"を付加したもの）以
		外に，リンクすべきオブジェクトファイルの名称を，".o"を付加した
		形で指定する．""で囲むことによって，複数のファイルを指定するこ
		とも可能である（-Uオプションを複数使ってはならない）．

	-L <カーネルライブラリのディレクトリ名>
		事前に構築したカーネルライブラリ（libkernel.a）を用いて，アプ
		リケーションのみを構築する場合には，このオプションにカーネルラ
		イブラリの置かれたディレクトリ名を指定する．このオプションの使
		用例については，「3.5 アプリケーションとカーネルを別々に構築す
		る方法」の節を参照すること．

	-f
		カーネルを関数単位でコンパイルしライブラリ化する場合に，このオ
		プションを指定する．このオプションの使用例については，「3.4 カ
		ーネルを関数単位でライブラリ化する方法」の節を参照すること．

	-D <ATK2-SC1のソースディレクトリ名>
		ATK2-SC1のソースファイルを置いたディレクトリ名を指定する．省
		略した場合には，configureの置かれているディレクトリとなる．

	-l <プログラミング言語>
		アプリケーションプログラムのプログラミング言語を指定する．現時
		点では，cのみをサポートしている．

	-t <テンプレートディレクトリ名>
		Makefileやサンプルプログラムのテンプレートの置かれたディレクト
		リ名を指定する．省略した場合には，ATK2-SC1のソースファイルを
		置いたディレクトリの下のsampleディレクトリとなる．

	-m <テンプレートMakefile名>
		Makefileのテンプレートとするファイル名を指定する．省略した場合
		には，Makefileとなる．

	-d <実行環境名>
		ターゲットシステム上でのプログラムの実行環境（ないしは，デバッ
		グ環境）の名称を指定する．このオプションを指定すると，実行環境
		を指定するシンボル（TOPPERS_<デバッグ環境名>）がマクロ定義され
		る．省略した場合には，実行環境を指定するシンボルはマクロ定義さ
		れない．

	-r
		トレースログ記録のサンプルコードを有効にする場合に，このオプシ
		ョンを指定する．このオプションの使用例については，「11.6 トレ
		ースログ記録のサンプルコードの使用方法」の節を参照すること．

	-p <perlのパス名>
		perlのパス名を指定する．省略した場合には，/usr/local/binと
		/usr/binを探索し，perlのパス名を決定する．

	-g <ジェネレータのパス名>
		ジェネレータ（cfg）のパス名を指定する．省略した場合には，デフォ
		ルトのパス名（ATK2-SC1のソースディレクトリの下のcfg/cfg/cfg)と
		なる．

	-o <オプション文字列>
		コンパイラに与えるオプション文字列で，シンボル定義以外のもの．
		シンボル定義のオプションは，-Oオプションを使用する．オプション
		文字列にスペースが含まれる場合には，"-O2 -Wall"のように，""で
		囲んで記述する必要がある．

	-O <オプション文字列>
		コンパイラに与えるシンボル定義のためのオプション文字列．オプシ
		ョン文字列にスペースが含まれる場合には，"-DTEST -DPERF"のよう
		に，""で囲んで記述する必要がある．

	-k <オプション文字列>
		リンカに与えるオプション文字列．オプション文字列にスペースが含
		まれる場合には，""で囲んで記述する必要がある．

コンフィギュレーションスクリプトが行う処理は次の通りである．

(1) Makefileの生成

テンプレートディレクトリ（デフォルトでは，sample）から適切なMakefileを
選択し，必要な箇所を書き換えて，Makefileを生成する．

(2) サンプルプログラムの生成

指定したアプリケーションプログラムがテンプレートディレクトリにある場
合，適切なアプリケーションプログラムのソースファイルを選択し，必要な箇
所を書き換えて，アプリケーションプログラムのソースファイル（例えば，
sample1.h，sample1.c，sample1.arxml）を生成する．

(3) ジェネレータが用意できているかのチェック

ジェネレータ（cfg）の実行ファイルがあるかチェックし，ファイルがない場
合には，その旨を出力する．


６．Makefileの修正方法

前の章で説明したように，コンフィギュレーションスクリプトに与えるオプシ
ョン等からMakefileが生成されるが，コンフィギュレーションスクリプトで対
応できない場合には，Makefileを直接修正する必要がある．ここでは，
Makefileの中で，修正が必要となる可能性の高い箇所について説明する．

なお，Makefileを修正した後にコンフィギュレーションスクリプトを再実行す
ると，修正したMakefileが上書きされてしまうので注意すること（古いものが
Makefile.bakに保存される）．

6.1 Makefileの変数定義

(A) ターゲット略称

TARGETには，ターゲットシステムの名称を，targetディレクトリの下に置かれ
ているターゲット依存部ディレクトリの名称で指定する．この定義は，通常
は，コンフィギュレーションスクリプトに対する-Tオプションにより行う．

(B) オブジェクトファイルの拡張子

Cygwin環境でコンパイルする時には，OBJEXTを"exe"に定義する必要がある．
これは，Cygwin環境では，ロードモジュールのファイル名に拡張子".exe"が付
加されるのに対応するためのものである．Cygwin環境であることを判定できれ
ば，コンフィギュレーションスクリプトがこの定義を行う．

(C) 実行環境（ターゲット依存）

ターゲットによっては，実行環境に対応してターゲット依存部のコードを差し
換える場合がある．これを可能にするために，実行環境の名称をDBGENVに定義
している．この定義は，通常は，コンフィギュレーションスクリプトに対す
る-Dオプションにより行う．どのターゲットがどの実行環境に対応しているか
は，ターゲット依存部のユーザーズマニュアルを参照すること．

(D) カーネルライブラリのディレクトリ名

KERNEL_LIBには，カーネルライブラリの置かれたディレクトリ名を定義する．
この定義は，通常は，コンフィギュレーションスクリプトに対する-Lオプショ
ンにより行う．

(E) カーネルを関数単位でコンパイルするかどうか

KERNEL_FUNCOBJSは，カーネルを関数単位でコンパイルする場合にはtrueに定
義し，ファイル単位でコンパイルする場合には未定義とする．この定義は，通
常は，コンフィギュレーションスクリプトに対する-fオプションにより行う．

(F) 共通コンパイルオプション

すべてのプログラムに共通するコンパイルオプションの追加が必要な場合に
は，下の変数の定義を変更する．そのコンパイルオプションが，特定のターゲ
ットで常に必要な場合には，ターゲット依存の定義を入れたMakefile.target
等を修正すべきである．

	CDEFS		コンパイラに対する-Dオプションを記述する．
	INCLUDES	コンパイラに対する-Iオプションを記述する．
	COPTS		コンパイラに対するその他のオプションを記述する．
	LDFLAGS		リンカに対するオプションを記述する．
	LIBS		ライブラリリンクのためのオプションを記述する．

追加の可能性のあるコンパイルオプションについては，「6.2 コンパイルオプ
ション」の節を参照のこと．

(G) アプリケーションプログラム名

APPLNAMEには，アプリケーションプログラム名を定義する．システムコンフィ
ギュレーションファイル名は，APPLNAMEに定義した名前に拡張子".arxml"を付
加した名前とする．また，アプリケーションのメインファイルは，APPLNAMEに
定義した名前に拡張子".c"を付加した名前とする．この定義は，通常は，コン
フィギュレーションスクリプトに対する-Aオプションにより行う．

(H) アプリケーションのディレクトリ名

アプリケーションのソースファイルを，オブジェクトファイルを置くのとは別
のディレクトリに置く場合には，APPLDIRにそのディレクトリ名を定義する．
この定義は，通常は，コンフィギュレーションスクリプトに対する-aオプショ
ンにより行う．アプリケーションのソースファイルを置くディレクトリが複数
ある場合には，APPL_DIRの定義を変更することで対応する．

(I) アプリケーションのプログラムファイル名

アプリケーションが複数のソースファイルで構成される場合には，そのオブジ
ェクトファイル名を，APPL_ASMOBJS，APPL_COBJS，APPL_CXXOBJSに列挙する．

(J) アプリケーションのコンパイルオプション

アプリケーションのコンパイルに必要なコンパイルオプションや，アプリケー
ションがライブラリを必要とする場合には，APPL_CFLAGSおよびAPPL_LIBSに定
義する．

(K) ロードモジュールのファイル名

標準のロードモジュールのファイル名をOBJNAMEに定義する．デフォルトは
atk2-sc1である．

(L) ターゲットファイルの定義

ターゲット"all"の依存ファイルとして，ロードモジュールの形式を指定す
る．具体的には，ELF形式の時は$(OBJFILE)，バイナリ形式の時は$(OBJNAME).
bin，モトローラ S形式の時は$(OBJNAME).srecを指定する．$(OBJFILE)は，
Cygwin環境でOBJEXTを"exe"に定義した時には$(OBJNAME).exe，そうでない場
合には$(OBJNAME)となる．

(M) makedepのオプションの定義

Cygwin環境でルートディレクトリが"cygdrive"でない場合には，makedepの-R
オプションでルートディレクトリ名を与える必要がある．また，Makefileのタ
ーゲット部（":"の左側）に複数のファイル名を記述すると（カーネルを関数
単位でライブラリ化する場合に，このような記述が生成される）正しく動作し
ない場合には（Cygwin環境のGNU Makeでこのような制限があるという報告があ
る），makedepに-Sオプションを付与する必要がある．

makedepのオプションは，次の例のように，MAKEDEP_OPTSに定義する．

MAKEDEP_OPTS = -R cygdrive -S

6.2 コンパイルオプション

ATK2-SC1のコード中には，ASSERTマクロが使われている．ASSERTマクロは，
NDEBUGを定義することで，オブジェクトコード中から消すことができる．カー
ネルのデバッグが終了すれば，-DNDEBUGを指定してコンパイルした方が効率が
よくなる．

ターゲット依存部において，コンパイルオプションに-Werror（警告をエラー
扱いする）を指定している場合がある．そのようなターゲットにおいて，アプ
リケーションで警告が避けられない場合には，ターゲット依存部を修正してコ
ンパイルオプションを削除する必要がある．

また，TOPPERS_OMIT_SYSLOGを定義してコンパイルすることで，システムログ
出力を抑止することができる．


７．ジェネレータの使い方

ジェネレータ（cfg）は，3つのパスで構成される．

ジェネレータは，システムコンフィギュレーションファイル名をパラメータに
取り，以下のオプションを持つ（重要なもののみ）．

	--help
		オプションのリストと説明を表示する．

	-v［--version］
		ジェネレータのバージョンを表示する．

	-k［--kernel］<カーネル名>
		カーネルの名称を指定する．デフォルトはatk2-sc1．

	-p［--pass］<パス番号>
		パス番号を指定する．1〜3のいずれか．

	-I［--include-path］<インクルードパス名>
		INCLUDEディレクティブにおいて，インクルードするコンフィギュレ
		ーションファイルを探すパス名を指定する．

	-T［--template-file］<テンプレートファイル名>
		テンプレートファイルの名称を指定する．パス2とパス3で有効．

	--cfg1-def-table <値取得シンボルテーブルファイル名>
		値取得シンボルテーブルのファイル名を指定する．

	-r［--rom-image］<ロードモジュール名>
		ロードモジュールをSレコードフォーマットの形に変換したファイル
		の名称を指定する．パス3でのみ有効．

	-s [--symbol-table] <シンボルファイル名>
		ロードモジュール中の各シンボルとアドレスの対応表を含むシンボル
		ファイルの名称を指定する．パス3でのみ有効．

	--id-output-file <ID番号出力ファイル名>
		オブジェクトのID番号の割付け結果を，指定した名前のファイルに書
		き出す．パス2でのみ有効．

	--id-input-file <ID番号入力ファイル名>
		オブジェクトのID番号の割付けを，指定した名前のファイルから取り
		込む．パス2でのみ有効．

	--external-id
		オブジェクトのID番号を保持する変数の定義を生成する．パス2での
		み有効．

	-M［--print-dependencies］<ターゲットシンボル>
		システムコンフィギュレーションファイルの依存関係を出力する．
		Makefile中の依存関係を生成する際に用いる．

	--ini-file <AUOTOSAR XML設定ファイル名>
		AUOTOSAR XMLコンフィギュレーションに必要なスキーマファイルな
		どの情報を，指定した名前のファイルから取り込む．XMLのコンフィ
		ギュレーションを行う．
		標準の<AUOTOSAR XML設定ファイル名>は，kernel/kernel.iniとして，
		ソースファイルに同梱している．開発環境に合わせて，配置場所やフ
		ァイル名を変更しても良い．
		例：<AUOTOSAR XML設定ファイル名>を，my_xml.iniにリネームして，
		アプリケーションファイルと同一フォルダに配置する場合は，以下の
		ようにMakefileのCFG_TABSオプションを修正する．

		#
		#  ジェネレータ関係の変数の定義
		#
		...省略
		CFG_KERNEL = atk2
		CFG_TABS := --ini-file ./my_xml.ini $(CFG_TABS)
		...省略

ジェネレータの詳細仕様については，別途PDFファイルの形で配布している
「TOPPERS新世代カーネル用コンフィギュレータ仕様」を参照すること．

7.1 コンフィギュレーションファイル(arxml)

OSのコンフィギュレーションは，AUTOSAR仕様に準拠したXMLベースのコンフィ
ギュレーションファイル(arxml)に記述する．しかし，XMLファイルは手動で作
成，編集するのが困難であるので，YAML(*)ファイルで記述したデータを，
AUTOSAR準拠のXMLファイルへ変換するツールである，ABREXを使用することを推
奨する．ABREXは，ユーティリティプログラムフォルダに入っている．使い方は，
utils/abrex/readme.txtを参照する．

(*)YAML：http://yaml.org/


８．システムモジュール

8.1 システムログ機能

システムログ機能は，カーネル内で発生した異常事象やカーネルのトレースロ
グ，システムサービスやアプリケーションで発生した異常事象やトレースログ
を，出力するための機能である．

システムログ機能を使うにはアプリケーションではじめにsyslog_initialize
を呼び出す必要がある．システムログ出力を行うソースファイルでは，
t_syslog.hをインクルードする．また，システムログ機能のその他のサービス
コールを呼び出すソースファイルでは，syslog.hをインクルードする．

8.1.1 低レベル出力

ATK2-SC1のシステムログ機能は低レベル出力機能のみを持つ．低レベル出力機
能は，ターゲット依存に用意する低レベルの文字出力関数（target_fput_log
）を用いてログ情報を出力する機能である．低レベルの文字出力関数は，ター
ゲット依存部で用意することとしているが，最終製品に組み込まれる場合など
では，文字を出力する方法がない状況も考えられる．そのような場合，低レベ
ルの文字出力関数に送られた文字は，メモリ上に残しておくか，捨ててしまう
しかない．

ログ情報を，低レベル出力機能を用いて出力するか
の設定は，システムログ機能のサービスコール（syslog_msk_log）によって行
うことができる．syslog_msk_logの使い方については後述する．デフォルトで
は（syslog_msk_logを呼び出さない場合），すべてのログ情報を低レベル出力
機能を用いて出力し，ログバッファには記録しない．

低レベル出力機能を用いると，ログメッセージの作成処理（printf相当の処
理）と低レベルの文字出力処理をカーネル内で行うために，カーネルの応答性
が悪くなることに注意しなければならない．特に，低レベルの文字出力処理は
デバイスをポーリングする形で実装するのが通常で，その場合には，カーネル
の応答性は実用的と言えない程に悪くなる．

8.1.2 ログ情報の種別

システムログ機能は，ログ情報に以下の種別を設けている．

		LOG_TYPE_COMMENT	コメント
		LOG_TYPE_ASSERT		アサーションの失敗

8.1.3 ログ情報の重要度

システムログ機能は，ログ情報を出力する際に指定する重要度に基づいて，実
際に出力するログ情報を動的に設定することができる．これは，UNIXのシステ
ムログ機能をまねたもので，ログの重要度の種類や指定方法もUNIXのAPIを参
考にしている．また，低レベル出力機能を用いて出力するログ情報も，重要度
に基づいて動的に設定することができる．

具体的には，ログの重要度として次の8段階を用意している．

		LOG_EMERG		カーネルの動作を継続できないエラー
		LOG_ALERT
		LOG_CRIT
		LOG_ERROR		重要性の低いシステムエラー
		LOG_WARNING		警告メッセージ．システムは安全に継続動作できる
		LOG_NOTICE
		LOG_INFO
		LOG_DEBUG		デバッグのためのメッセージ

どの重要度のログ情報をログバッファに記録するかと，どの重要度のログ情報
を低レベル出力機能を用いて出力するかは，システムログ機能のサービスコー
ル（syslog_msk_log）によって設定することができる．

8.1.4 ログ情報のデータ構造

ログ情報を格納するためのデータ型として，SYSLOG構造体を用意している．
SYSLOG構造体には，ログ情報の種別（logtypeフィールド），ログ時刻
（logtimフィールド），その他のログ情報（loginfoフィールド）が含まれ
る．ATK2ではログ時刻は使わない．

8.1.5 システムログ機能のサービスコール

システムログ機能の提供するサービスコールは次の通りである．これらのサー
ビスコールを呼び出すソースファイルでは，syslog.hをインクルードする必要
がある．

(1) StatusType syslog_wri_log(uint32 prio, const SYSLOG *p_syslog)

システムログ機能に，p_syslogで指定されるログ情報を，prioで指定される重
要度で出力する（ログバッファへ記録するか低レベル出力機能を用いて出力す
る）．

(2) StatusType syslog_msk_log(uint32 lowmask)

ログバッファに記録すべきログ情報の重要度の示すビットマップ（logmask）
と，低レベル出力機能を用いて出力すべきログ情報の重要度を示すビットマッ
プ（lowmask）を設定する．ビットマップを作るためのマクロとして，
LOG_MASKとLOG_UPTOを用意している．

8.1.6 システムログ機能のためのライブラリ関数とマクロ

システムログ出力のためのライブラリ関数とマクロは次の通りである．これら
だけを呼び出すソースファイルでは，t_syslog.hをインクルードすればよい．

(1) void _syslog_n(uint32 prio, uint32 type, uintptr arg1, ...,
                                                        uintptr argn)
    ※ nは1〜6のいずれか．

ログ種別がtype，パラメータがarg1〜argnのログ情報を，重要度prioで出力す
るための関数．

(2) void syslog_n(uint32 prio, const char *format, arg1, ..., argn)
    ※ nは0〜5のいずれか．

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するためのマクロ．

formatはメッセージのフォーマット記述，arg1〜argnはフォーマット記述中で
参照される値で，printfのフォーマット記述のサブセットとなっている．arg1
〜argnは，このマクロ中でuintptr型にキャストされるため，uintptr型に型変
換できる任意の型を渡すことができ，型チェックはされない．formatおよび
arg1〜argnには，次の制限がある．

・formatのフォーマット記述は，定数文字列を渡すことを想定しており，この
マクロ処理を終えた後も変化してはならない．

・format中に使えるフォーマット指定は次の通り．

	%d		引数をsint32型とみなし，10進数で表示
	%u		引数をuint32型とみなし，10進数で表示
	%x		引数をuint32型とみなし，16進数（英文字は小文字）で表示
	%X		引数をuint32型とみなし，16進数（英文字は大文字）で表示
	%p		引数をポインタとみなし，16進数（英文字は小文字）で表示
	%c		引数を文字コードとみなし，文字を表示
	%s		引数を文字列を示すポインタとみなし，文字列を表示
	%%		'%'を表示（引数は取らない）

%d, %u, %x, %Xにおいては，'%'の直後に表示桁数を指定する10進数値を記述
することができる．その場合，表示すべき文字列が指定した桁数に満たない場
合には，指定した桁数内に右詰めで表示する．10進数値が'0'で始まる場合に
は，その間に'0'を埋める．

また，sintptr型のサイズがlong型のサイズ以上である環境においては，次の
フォーマット指定も使用することができる．この他のフォーマット指定に'l'
を付加した場合には無視する（%lcと%lsには対応していない）．

	%ld		引数をlong型とみなし，10進数で表示
	%lu		引数をunsigned long型とみなし，10進数で表示
	%lx		引数をunsigned long型とみなし，16進数（英文字は小文字）で
	        表示
	%lX		引数をunsigned long型とみなし，16進数（英文字は大文字）で
	        表示

・arg1〜argnにポインタを渡す場合（%sに対応する引数の場合）に，ポインタ
の指すデータは，このマクロ処理を終えた後も変化してはならない．定数文字
列を渡すことを想定している．

(3) void syslog(uint32 prio, const char *format, ...)

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するための関数で，引
数の数を可変にしたもの．formatに続く引数は最大5個まで．formatおよびそ
れに続く引数には，syslog_nと同様の制限がある．

このライブラリ関数は，可変数引数を処理するために内部で文字列をスキャン
する．そのため，実行時間が長くなる可能性があり，割込み禁止状態で呼び出
すべきではない．主にアプリケーションプログラムが用いることを想定してい
る．

(4) uint32 LOG_MASK(uint32 prio)

重要度prioのみセットされたビットマップを作るマクロ．syslog_msk_logに渡
す引数を作るために用いる．

(5) uint32 LOG_UPTO(uint32 prio)

重要度prio以上の重要度がすべてセットされたビットマップを作るマクロ．
syslog_msk_logに渡す引数を作るために用いる．

8.1.7 システムログ機能のその他のサービス

システムログ機能は，前記のサービスコール等に加えて，初期化処理のための
関数を持つ．

(1) void syslog_initialize(void)

システムログ機能を初期化する．ログバッファにログ情報が記録されている場
合には，消去される．シスログ機能を使う場合にスタートアップフックから呼
ばれることを想定している．

(2)トレースログバッファのサイズ指定（SYSLOG構造体サイズ）
カーネルのトレースログを保持するため，トレースログバッファのサイズを指
定することが出来る．トレースログバッファのサイズを指定する場合，コンパ
イルに対する-Dオプションで指定できる．例えばトレースログバッファのサイ
ズを512にする場合，以下のオプションで記述する．
CDEFS := $(CDEFS)  -DTCNT_TRACE_BUFFER=512

また，TCNT_TRACE_BUFFERマクロ指定しない場合，デフォルトのトレースログ
バッファのサイズは，8192である．

注意：トレースログバッファが一杯になった場合，次のログから最初に保持し
たログを書き換える．

8.2 シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルポートを扱うためのドライバで
ある．

シリアルインタフェースドライバを呼び出すソースファイルでは，serial.hを
インクルードする．

8.2.1 シリアルインタフェースドライバのサービスコール

シリアルインタフェースドライバを呼び出すサービスコールの仕様は次の通り
である．

(1) void InitSerial(void)

シリアルインタフェースドライバを初期化処理を行う．シリアルインタフェー
スドライバを使う前に1度だけ呼び出す．

(2) void TermHwSerial(void)

シリアルインタフェースドライバの終了処理を行う．

(3) void RecvPolSerialChar(uint8 *character)

受信した1バイトのデータをcharacterに入れる．受信したデータがない場合は
0を入れる．

8.3 カーネル起動メッセージの出力

カーネル起動メッセージの出力は，カーネルの起動時に，カーネルの名称やバ
ージョン番号などを出力するための機能である．

カーネル起動メッセージの出力は，次の関数で構成される．

(1) void print_banner(void)

システムログ機能を用いて，カーネル起動メッセージを出力する．


９．サポートライブラリ

サポートライブラリは，アプリケーションやライブラリを作成するために利用
できるライブラリ関数群である．

9.1 基本的なライブラリ関数

基本的なライブラリ関数を用いる場合には，t_stdlib.hをインクルードし，必
要に応じてstrerror.cとt_perror.cをコンパイル・リンクする．

(1) const char *atk2_strerror(StatusType ercd)

ercdで示されるエラーコードに対応するメインエラーコードの文字列を返す．

(2) void t_perror(uint32 prio, const char *file, sint32 line,
								const char *expr, StatusType ercd);

サービスコールがエラーを返した場合に用いることを想定した関数で，ファイ
ル名，行番号，メインエラーコード等を，重要度prioで，システムログ機能を
用いて出力する．

9.2 キュー操作ライブラリ関数

キュー操作ライブラリは，キューヘッダを含むリング構造のダブルリンクキュ
ーを扱うライブラリである．キューヘッダの次エントリはキューの先頭のエン
トリ，前エントリはキューの末尾のエントリとする．また，キューの先頭のエ
ントリの前エントリと，キューの末尾のエントリの次エントリは，キューヘッ
ダとする．空のキューは，次エントリ，前エントリとも自分自身を指すキュー
ヘッダであらわす．

キュー操作ライブラリ関数を用いる場合には，queue.hをインクルードする．

キューヘッダとエントリのためのデータ構造として，QUEUE構造体を用いる．
QUEUE構造体の定義は次の通り．

	typedef struct queue {
		struct queue *p_next;		/* 次エントリへのポインタ */
		struct queue *p_prev;		/* 前エントリへのポインタ */
	} QUEUE;

キュー操作のために用意している関数は次の通り．

(1) void queue_initialize(QUEUE *p_queue);

キューを初期化する．p_queueにはキューヘッダを指定する．

(2) void queue_insert_prev(QUEUE *p_queue, QUEUE *p_entry);

p_queueで指定するエントリの前に，p_entryで指定するエントリを挿入する．
p_queueにキューヘッダを指定した場合には，キューの末尾にp_entryで指定す
るエントリを挿入することになる．

(3) void queue_insert_next(QUEUE *p_queue, QUEUE *p_entry);

p_queueで指定するエントリの次に，p_entryで指定するエントリを挿入する．
p_queueにキューヘッダを指定した場合には，キューの先頭にp_entryで指定す
るエントリを挿入することになる．

(4) void queue_delete(QUEUE *p_entry);

p_entryで指定するエントリを，キューから削除する．

(5) QUEUE *queue_delete_next(QUEUE *p_queue);

p_queueで指定するエントリの次のエントリをキューから削除し，削除したエ
ントリを返す．p_queueにキューヘッダを指定した場合には，キューの先頭の
エントリを取り出すことになる．p_queueに空のキューを指定して呼び出して
はならない．

(6) boolean queue_empty(QUEUE *p_queue);

キューが空の場合にはTRUE，そうでない場合にはFALSEを返す．p_queueには
キューヘッダを指定する．

9.3 システムログ出力用ライブラリ関数

システムログ出力用ライブラリ関数は，ログ情報をフォーマット出力するため
に，システムログ機能で用いるための関数群である．

システムログ出力用ライブラリ関数を用いる場合には，log_output.hをインク
ルードし，log_output.cをコンパイル・リンクする．

(1) void syslog_printf(const char *format, const uintptr *p_args,
												void (*putc)(char))

formatで指定されるフォーマット記述とp_argsで指定される引数列から作成し
たメッセージを，1文字出力関数putcを用いて出力する．

(2) void syslog_print(const SYSLOG *p_syslog, void (*putc)(char))

p_syslogで指定されるログ情報を文字列に直し，1文字出力関数putcを用いて
出力する．

9.4 実行時間分布集計モジュール

実行時間分布集計モジュールは，システムのリアルタイム性能を評価するため
に，プログラム区間の実行時間を計測し，その分布を集計・表示するためのラ
イブラリ関数群である．

実行時間分布集計モジュールを用いる場合には，histogram.hをインクルードし，
histogram.cをコンパイル・リンクする．

実行時間分布集計モジュールは，複数のプログラム区間の実行時間を計測・集
計・表示することができる．プログラム区間毎に，実行時間分布を記録するた
めのデータ構造を持つ．どのデータ構造を用いるかを，ID番号（histid）で指
定する．使用できるデータ構造の数は，TNUM_HISTで定義される．すなわち，
ID番号として，1〜TNUM_HISTを指定することができる．TNUM_HISTは，デフォ
ルト値がhistgram.cの中で定義されており，コンパイルオプションやターゲッ
ト依存部（target_test.hまたはそこからインクルードされるファイル）によ
り変更することができる．

ターゲット依存部で設定を変更していない場合，実行時間分布集計モジュール
は，カーネルの性能評価用システム時刻を参照する機能（get_tim_utime）を
用いて実行時間を計測する．そのため，実行時間はマイクロ秒単位で記録され
る（精度はターゲット依存）．また，記録される時間には，計測のためのオー
バヘッド（get_tim_utimeの実行時間＋α）が含まれる．

ターゲット依存部で設定を変更している場合の仕様については，ターゲット依
存部のユーザーズマニュアルを参照すること．

(1) boolean init_hist(ObjectIDType histid, uint32 maxval,
                                                    uint32 *histarea)

histidで指定されたデータ構造を初期化する．maxvalには記録する最大時間
を，histareaには記録領域の先頭番地を指定する．histareaで始まる記憶領域
は，要素数がmaxvalに指定した値+1のuint32型の配列として確保する．例え
ば，maxvalに1000を指定する場合には，histareaには要素数が1001のuint32型
の配列の先頭番地を渡す．histidが正常な場合はTRUEを返し，不正な場合は
FALSEを返す．

(2) boolean begin_measure(ObjectIDType histid)

実行時間を計測するプログラム区間の直前に呼び出す関数．histidで指定され
たデータ構造に，現在のシステム時刻を記録する．histidが不正な場合や
init_histが呼ばれていない場合はFALSEを返し，そうでない場合はTRUEを返
す．

(3) boolean end_measure(ObjectIDType histid)

実行時間を計測するプログラム区間の直後に呼び出す関数．現在のシステム時
刻と，histidで指定されたデータ構造に記録された開始時刻から，プログラム
区間の実行時間を求め，その結果を記録する．histidが不正な場合や
init_histが呼ばれていない場合はFALSEを返し，そうでない場合はTRUEを返
す．


(4) boolean print_hist(ObjectIDType histid)

システムログ機能を用いて，実行時間分布の計測結果を出力する．histidが不
正な場合やinit_histが呼ばれていない場合はFALSEを返し，そうでない場合は
TRUEを返す．



１０．使用上の注意とヒント

10.1 タイマドライバの組込み

ターゲット依存部にtarget_timer.arxmlという名称のコンフィギュレーション
ファイルが用意されている．タイマドライバをシステムに組み込むために，コ
ンフィギュレーションスクリプトの，コンフィギュレーションファイルを指定
するオプション（-C）を使って，target_timerを追加すると便利である．また，
リンクするオブジェクトファイルを追加するオプション（-U）を使って，
target_timer.oを追加すると便利である．（独自に定義しても差し支えない）．

10.2 ASSERTマクロの処理

ATK2-SC1のコード中には，ASSERTマクロが使われている．ASSERTマクロの定義
はkernel_impl.hに含まれ，ASSERTが失敗した場合の最後の処理は，シャット
ダウンである．

10.3 システムログ機能の扱い

TOPPERS/ATK2-SC1では，システム開発時の利便性を考慮し，システムログ機
能を組み込む設定をデフォルトとしている．

それに対して，TOPPERS/ATK2-SC1を用いたシステムを機器に組み込む場合は，
システムログ機能が意味がない場合も多い．機器への組込みに際してのシステ
ムログ機能の設定方法には，以下の方法が考えられる．

(1) システムログ機能を用いない

システムログ機能のサービスコールを呼び出すソースファイルに
TOPPERS_OMIT_SYSLOGを定義してコンパイルすればよい．

(2) 開発時の設定のままとする

システムログ機能の設定を，システム開発時のまま変更せず，シリアルポート
等にログ情報を垂れ流す方法も考えられる．

10.4 オブジェクトIDの管理

TOPPERS/ATK2-SC1では，オブジェクトのID番号を，ジェネレータが割り付ける
方法が基本となっている．

アプリケーションプログラム中でオブジェクトのID番号を参照する場合には，
次の2つの方法が考えられる．

(1) オブジェクト識別名を用いる

オブジェクト生成のためのコンテナのショートネームに記述したオブジェクト
識別名を，アプリケーションプログラム中でも用いる方法．

ジェネレータは，オブジェクト識別名を，割り付けたID番号にマクロ定義する
C言語プリプロセッサのディレクティブ（#define）をOs_Lcfg.hに生成するた
め，アプリケーションプログラムからOs_Lcfg.hをインクルードする必要があ
る．

この方法は，オブジェクトコード中にID番号が直接埋め込まれるために実行効
率が良い一方で，ジェネレータが実行されてOs_Lcfg.hが書き換わる度に，ア
プリケーションプログラムの再コンパイルが必要になるという欠点がある．そ
のため，アプリケーションプログラムを構成するファイルの中で，一部のファ
イルのみでオブジェクト識別名を参照する構成にするといった工夫をすること
が望ましい．

(2) オブジェクトのID番号を保持する変数を用いる

オブジェクトのID番号を保持するconst属性を付加した変数を用意し，アプリ
ケーションプログラム中では，その変数を用いる方法．

例えば，TASK1というオブジェクト識別名のタスクに対して，次のような変数
を用意する．

const TaskType TASK1_id = TASK1;

アプリケーションプログラム中では，この変数（TASK1_id）を用いることで，
ジェネレータが実行されてOs_Lcfg.hが書き換わる度に，上記の変数定義を含
んだファイルのみを再コンパイルすればよいことになる．

この方法は，アプリケーションプログラムの再コンパイルを最小限にできる利
点がある一方で，変数のためのメモリ領域が必要になることに加えて，（プロ
セッサによっては）変数アクセスのためのオーバヘッドが生じるという欠点が
ある．また，定数ではなく変数であることから，他の変数の初期化には使えな
いという制限がある．

なお，TOPPERS/ATK2-SC1のジェネレータは，--external-idオプションを付加す
ることにより，上記の変数定義をOs_Lcfg.c中に生成する機能を持っているので，
すべてのオブジェクトIDをこの方法で参照する場合には，この機能を用いるこ
とを推奨する．

10.5 トレースログ記録のサンプルコードの使用方法

トレースログ記録のサンプルコードがターゲット依存部に組み込まれている場
合には，コンフィギュレーションスクリプトにそれを使用することを指示する
オプション（-r）を付加することで，メモリ上にトレースログを記録する機能
が有効になる．記録されたトレースログはシャットダウン時にターゲット依存
の低レベル出力機能（target_fput_log）を利用してダンプされる．
トレースログ記録には，後述のシステムタイマが必要である．

10.6 システムの起動時の初期化処理

システムの起動時にアプリケーションで必要となる初期化処理を行うための機
能としてスタートアップフックが用意されているが，スタートアップフックが
実行されるよりも早いタイミングで実行することが必要な初期化処理がある場
合がある．

このような場合に用いるために，標準的なスタートアップモジュールから，ター
ゲットシステム依存の初期化フック（hardware_init_hook）を呼び出すことと
している．hardware_init_hookは，カーネルのターゲット依存部で用意されて
いるのが標準であるが，これをアプリケーションで用意したものに置き換え，
その中でアプリケーションで必要となる初期化処理を行うことができる．

ただし，hardware_init_hookの作成する場合には，bssセクションとdataセク
ションが初期化されていないことや，ライブラリが初期化されていないこと，
C言語で記述できるとは限らないことなどに注意が必要である．作成にあたっ
ては，「ターゲット依存部 ポーティングガイド」を参照すること．

カーネルのスタートアップモジュールがhardware_init_hookを呼び出すように
実装されていない場合には，スタートアップモジュールをアプリケーションで
用意したものに置き換える方法を推奨する．

10.7 想定するプログラミング言語

本カーネルにおけるAPI仕様は，ISO/IEC 9899:1990（C90と呼ぶ）またはISO/
IEC 9899:1999（C99と呼ぶ）に準拠したC言語を，フリースタンディング環境
で用いることを想定している．

ただし，C90の規定に加えて，以下のことを仮定している．
 ・16ビット及び32ビットの整数型があること
 ・ポインタが格納できるサイズの整数型があること
 ・long long型を使用できること
 ・変数など31文字以下で識別できる制約がないこと
 ・オブジェクトサイズ32767バイト以下の制限がないこと
 ・#ifの入れ子8個までの制限がないこと
 ・1モジュール#deinfe数1024個以下の制限がないこと
 ・インライン関数を使用できること

10.8 ユーザスタック領域定義

本カーネルでは，各スタックのユーザ指定をサポートし，アラインを守るため
にスタックタイプ(StackType)を用意している．
スタック領域は，標準では，StackType型の配列として確保するが，ユーザは，
都合よりバイト単位(他のタイプを含む)で確保する場合，アラインを守る必要
もあるため，以下のマクロ関数を適切に使う．

 ・COUNT_STK_T(sz)  szで指定したバイト単位のサイズをアライン考慮して
                    (丸めて)，StackType単位に変換したサイズを返す
 ・ROUND_STK_T(sz)  szで指定したバイト単位のサイズをアライン考慮して
                    (丸めて)，StackType単位に変換した後，バイト単位に
                    再変換したサイズを返す
                    
例(StackTypeのアラインは4の場合）：
  ・COUNT_STK_T(1)の戻り値は，(1+(4-1)/4=)1となり，
    COUNT_STK_T(4+(4-1)/4=)も1になり，COUNT_STK_T(110)の戻り値は,
    (110+(4-1)/4=)38になる．
  ・ROUND_STK_T(1)の戻り値は，(1+(4-1)&0xfffffff1=)4になり，
    COUNT_STK_T(110)の戻り値は，(110+(4-1)&0xfffffff1=)112になる．

10.9 スタックサイズを見積もる際の注意点

本カーネルは，C2ISR/フックのスタックは，合わせて1つのスタックで確保さ
れる．本カーネルでは，コンフィギュレーション時にスタックサイズを指定す
る場合，C2ISR/フック/C1ISRの他に，OSが使用する分を考慮する必要がある．

例えば，タスク実行中に割込みが発生した場合は，レジスタ退避のためにタス
クスタックを(※)使用する．その後，C2ISR用スタックにスタックを切り替え
る際のレジスタ退避には，C2ISR用スタックを(※)使用する．
※で使用するスタック量は，ターゲット及びコンパイラに依存する．

また，スタックサイズを見積もる際に，タスク/C2ISR/フック/C1ISRのネスト
実行を考慮する必要がある．
例えば，C2ISRのスタックを見積もる際，C2ISR処理中により高い優先度の
C2ISRが発生した場合やC2ISR処理中にエラーフックが発生た場合，レジスタ退
避のために，C2ISR用スタックを使用する．

10.10 スタートアップ/シャットダウンフック無効時の注意点

本カーネルに添付しているサンプルソースコードは，カーネルの動作を確認
するための一例と位置付けである．添付しているサンプルでは，スタートアッ
プフック処理に，ターゲットタイマーの初期化，システムログ機能の初期化と
シリアルモジュールの初期が処理している．サンプルソースの動作は，スター
トアップフックが常に有効と仮定しているため，サンプルコンフィギュレーシ
ョンを修正して，スタートアップフックを無効にした場合，前述初期化処理が
実行されなくなり，サンプルは，動作しなくなる．

スタートアップフックを無効にしても，サンプルを動作させたい場合は，スタ
ートアップフックにある各初期化処理をスタートモジュールや，main()関数等
StartOS()を呼ぶ前，適切に呼ぶ必要がある．

また，スタートアップフックで各初期化処理を実施していると同様，シャット
ダウンフックでターゲットタイマーとシリアルモジュールの停止処理を実施し
ているので，シャットダウンフックを無効にした場合，カーネルを終了する前
（ShutdownOS()を呼ぶ前）に，これらの停止処理を実施すべきである．

10.11 システムタイマの使用方法

システムタイマ(タイマドライバ)用のコードがターゲット依存部に組み込まれ
ている場合には，コンフィギュレーションスクリプトにそれを使用することを
指示するオプション（-s）を付加することで，1ミリ秒単位のシステムタイマが
有効になる．


１１．参考情報

11.1 利用条件と利用報告

ATK2-SC1の利用条件は，各ファイルの先頭に表示されている．著作権は，各フ
ァイルの先頭に表示されている著作権者が保有している．

利用条件の(3)の(b)において，利用の形態をTOPPERSプロジェクトに報告する
方法としては，ATK2-SC1を利用した製品の名称と応用分野，製品化した会社名
と業種等の情報を，以下のURLのページから報告するものとする．

	http://www.toppers.jp/report.html

またその際に，ATK2-SC1を使用してのコメントやご意見もいただけると幸いで
ある．

11.2 保証・適用性・サポート

ATK2-SC1は無保証で提供されているものである．開発者およびTOPPERSプロジ
ェクトは，ATK2-SC1に関して，特定の使用目的に対する適合性も含めて，いか
なる保証も行わない．また，ATK2-SC1の利用により直接的または間接的に生じ
たいかなる損害に関しても，その責任を負わない．

開発者およびTOPPERSプロジェクトは，ATK2-SC1に関するサポートの約束はし
ていない．ATK2-SC1に関して質問がある場合は，後述のTOPPERSユーザーズメ
ーリングリストを利用していただけると幸いである．確実なサポートが必要な
場合には，有償でサポートサービスを提供している会社に相談されたい．

11.3 バグレポート

ATK2-SC1にバグや問題点を発見された場合には，後述のTOPPERSユーザーズメ
ーリングリストに報告して欲しい．

メーリングリストにバグや問題点などを報告する場合には，必要に応じて次の
情報を知らせて欲しい．

	使用しているカーネルに関する情報
		・ターゲット非依存部のバージョン
		・使用しているターゲット依存部とそのバージョン
		・TOPPERSプロジェクトからのリリースに対する改造箇所（あれば）

	ターゲットシステムに関する情報
		・ターゲットプロセッサの種類
		・ターゲットボード等の種類

	ホストに関する情報
		・OSのバージョン（サービスパックの適用状況も）
		・コンパイラなどの開発環境のバージョン（Cygwinのバージョンも）

11.4 ウェブサイト

TOPPERSプロジェクトのウェブサイトは，以下のURLにある．

	http://www.toppers.jp/

TOPPERSプロジェクトやATK2-SC1に関する最新情報は，このウェブサイトか
ら得ることができる．また，ATK2-SC1の最新版は，このウェブサイトからダ
ウンロードすることができる．

11.5 TOPPERSユーザーズメーリングリスト

ATK2-SC1を含むTOPPERSプロジェクトの開発成果物のユーザに対する情報提
供およびユーザ相互間の情報交換を容易にするために，TOPPERSユーザーズメ
ーリングリスト（users@toppers.jp）を用意している．

このメーリングリストには，誰でも自由に登録し，メールを送付することがで
きる（登録者以外はメールを送付できない）．また，送付されたメールは，誰
でも自由にウェブサイトで読むことができる．

メーリングリストへの登録方法については，以下のURLのページに説明がある．

	http://www.toppers.jp/community.html

11.6 TOPPERSプロジェクトのメンバ向けのサービス

TOPPERSプロジェクトのメンバに対しては，上記に加えて，ATK2-SC1に関連
して次のサービスを用意している．

(1) TOPPERS開発者メーリングリスト

TOPPERSプロジェクトのメンバは，ATK2-SC1に関する質問，バグや問題点な
どの報告に，TOPPERS開発者メーリングリスト（dev@toppers.jp）を利用する
ことができる．

11.7 TOPPERSプロジェクトへの参加

TOPPERSプロジェクトでは，何からの形でプロジェクトに貢献していただける
方，プロジェクトで開発したソフトウェアをお使いの方，プロジェクトに興味
をお持ちの方の参加を求めている．TOPPERSプロジェクトへの参加方法につい
ては，以下のページに説明がある．

	http://www.toppers.jp/joinus.html



以上
